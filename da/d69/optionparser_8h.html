<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Beam Longitudinal Dynamics code (BLonD): optionparser.h File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='../../open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='../../closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='../../closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="../../globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>optionparser.h File Reference</h1>
<p>This is the only file required to use The Lean Mean C++ Option Parser. Just #include it and you're set.  
<a href="#_details">More...</a></p>
<div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dynsection">
<div class="center"><img src="../../d6/db9/optionparser_8h__dep__incl.png" border="0" usemap="#optionparser_8hdep_map" alt=""/></div>
<map name="optionparser_8hdep_map" id="optionparser_8hdep">
<area shape="rect" id="node3" href="../../de/df0/utilities_8h.html" title="utilities.h" alt="" coords="980,83,1055,112"/><area shape="rect" id="node5" href="../../d5/dfa/InducedVoltage_8cpp.html" title="InducedVoltage.cpp" alt="" coords="315,392,451,421"/><area shape="rect" id="node7" href="../../d4/dfd/plot__slices_8cpp.html" title="plot_slices.cpp" alt="" coords="2043,392,2152,421"/><area shape="rect" id="node9" href="../../d7/d74/Beams_8h.html" title="Beams.h" alt="" coords="1603,160,1677,189"/><area shape="rect" id="node24" href="../../dc/d7d/Distributions_8h.html" title="Distributions.h" alt="" coords="1437,624,1544,653"/><area shape="rect" id="node26" href="../../d3/d33/PhaseLoop_8h.html" title="PhaseLoop.h" alt="" coords="903,469,1001,499"/><area shape="rect" id="node30" href="../../d0/da6/Monitors_8h.html" title="Monitors.h" alt="" coords="1713,547,1796,576"/><area shape="rect" id="node34" href="../../d2/d0e/Tracker_8h.html" title="Tracker.h" alt="" coords="188,547,265,576"/><area shape="rect" id="node39" href="../../d9/dc8/PhaseNoise_8h.html" title="PhaseNoise.h" alt="" coords="1147,392,1251,421"/><area shape="rect" id="node59" href="../../dc/df2/Slices_8h.html" title="Slices.h" alt="" coords="1195,237,1264,267"/><area shape="rect" id="node66" href="../../d7/d76/fft_8h.html" title="fft.h" alt="" coords="831,160,876,189"/><area shape="rect" id="node68" href="../../d2/de2/math__functions_8h.html" title="math_functions.h" alt="" coords="691,315,813,344"/><area shape="rect" id="node80" href="../../d6/d70/Intensity_8h.html" title="Intensity.h" alt="" coords="157,237,240,267"/><area shape="rect" id="node87" href="../../d5/d34/GeneralParameters_8h.html" title="GeneralParameters.h" alt="" coords="1835,160,1979,189"/><area shape="rect" id="node96" href="../../d4/dba/LHCNoiseFB_8h.html" title="LHCNoiseFB.h" alt="" coords="897,315,1007,344"/><area shape="rect" id="node11" href="../../dc/d0f/Beams_8cpp.html" title="Beams.cpp" alt="" coords="576,392,664,421"/><area shape="rect" id="node13" href="../../d5/d87/globals_8h.html" title="globals.h" alt="" coords="1296,315,1371,344"/><area shape="rect" id="node44" href="../../d6/db7/RfParameters_8h.html" title="RfParameters.h" alt="" coords="1704,237,1819,267"/><area shape="rect" id="node49" href="../../d8/d94/plot__beams_8h.html" title="plot_beams.h" alt="" coords="1960,315,2059,344"/><area shape="rect" id="node15" href="../../d7/d91/Slices_8cpp.html" title="Slices.cpp" alt="" coords="1040,392,1123,421"/><area shape="rect" id="node17" href="../../da/d77/globals_8cpp.html" title="globals.cpp" alt="" coords="1528,392,1616,421"/><area shape="rect" id="node20" href="../../dc/d61/RfParameters_8cpp.html" title="RfParameters.cpp" alt="" coords="1325,392,1453,421"/><area shape="rect" id="node22" href="../../d3/db7/LHCNoiseFB_8cpp.html" title="LHCNoiseFB.cpp" alt="" coords="789,392,915,421"/><area shape="rect" id="node28" href="../../db/dee/PhaseLoop_8cpp.html" title="PhaseLoop.cpp" alt="" coords="736,547,848,576"/><area shape="rect" id="node32" href="../../da/dda/Monitors_8cpp.html" title="Monitors.cpp" alt="" coords="1707,624,1803,653"/><area shape="rect" id="node36" href="../../d2/d6f/Tracker_8cpp.html" title="Tracker.cpp" alt="" coords="45,624,136,653"/><area shape="rect" id="node41" href="../../db/d82/PhaseNoise_8cpp.html" title="PhaseNoise.cpp" alt="" coords="728,469,845,499"/><area shape="rect" id="node53" href="../../d2/d51/plot__slices_8h.html" title="plot_slices.h" alt="" coords="1843,315,1936,344"/><area shape="rect" id="node51" href="../../d3/d2c/plot__beams_8cpp.html" title="plot_beams.cpp" alt="" coords="1904,392,2019,421"/><area shape="rect" id="node73" href="../../d1/dca/Intensity_8cpp.html" title="Intensity.cpp" alt="" coords="93,392,189,421"/><area shape="rect" id="node83" href="../../d9/dee/InducedVoltage_8h.html" title="InducedVoltage.h" alt="" coords="43,315,165,344"/><area shape="rect" id="node89" href="../../da/d56/GeneralParameters_8cpp.html" title="GeneralParameters.cpp" alt="" coords="1944,237,2101,267"/></map>
</div>

<p><a href="../../da/d69/optionparser_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dc3/structoption_1_1Arg.html">option::Arg</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functions for checking the validity of <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a> arguments.  <a href="../../df/dc3/structoption_1_1Arg.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dfe/structoption_1_1Descriptor.html">option::Descriptor</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Describes an <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a>, its help text (usage) and how it should be parsed.  <a href="../../dc/dfe/structoption_1_1Descriptor.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/df3/classoption_1_1Option.html">option::Option</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A parsed <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a> from the command line together with its argument if it has one.  <a href="../../d3/df3/classoption_1_1Option.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d83/classoption_1_1Parser.html">option::Parser</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks argument vectors for validity and parses them into data structures that are easier to work with.  <a href="../../d6/d83/classoption_1_1Parser.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d83/classoption_1_1Parser.html">option::Parser</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks argument vectors for validity and parses them into data structures that are easier to work with.  <a href="../../d6/d83/classoption_1_1Parser.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d83/classoption_1_1Parser.html">option::Parser</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks argument vectors for validity and parses them into data structures that are easier to work with.  <a href="../../d6/d83/classoption_1_1Parser.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dfb/structoption_1_1PrintUsageImplementation.html">option::PrintUsageImplementation</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dae/structoption_1_1PrintUsageImplementation_1_1FunctionWriter.html">option::PrintUsageImplementation::FunctionWriter&lt; Function &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d0b/structoption_1_1PrintUsageImplementation_1_1IStringWriter.html">option::PrintUsageImplementation::IStringWriter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html">option::PrintUsageImplementation::LinePartIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html">option::PrintUsageImplementation::LineWrapper</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/deb/structoption_1_1PrintUsageImplementation_1_1OStreamWriter.html">option::PrintUsageImplementation::OStreamWriter&lt; OStream &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d60/structoption_1_1PrintUsageImplementation_1_1StreamWriter.html">option::PrintUsageImplementation::StreamWriter&lt; Function, Stream &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d44/structoption_1_1PrintUsageImplementation_1_1SyscallWriter.html">option::PrintUsageImplementation::SyscallWriter&lt; Syscall &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/da8/structoption_1_1PrintUsageImplementation_1_1TemporaryWriter.html">option::PrintUsageImplementation::TemporaryWriter&lt; Temporary &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/structoption_1_1Stats.html">option::Stats</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines the minimum lengths of the buffer and options arrays used for <a class="el" href="../../d6/d83/classoption_1_1Parser.html" title="Checks argument vectors for validity and parses them into data structures that are...">Parser</a>.  <a href="../../d8/de3/structoption_1_1Stats.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de3/structoption_1_1Stats.html">option::Stats</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines the minimum lengths of the buffer and options arrays used for <a class="el" href="../../d6/d83/classoption_1_1Parser.html" title="Checks argument vectors for validity and parses them into data structures that are...">Parser</a>.  <a href="../../d8/de3/structoption_1_1Stats.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/de0/namespaceoption.html">option</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The namespace of The Lean Mean C++ <a class="el" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> <a class="el" href="../../d6/d83/classoption_1_1Parser.html" title="Checks argument vectors for validity and parses them into data structures that are...">Parser</a>. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ArgStatus(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/de0/namespaceoption.html#a4afb7f04597f34439679509baf4b6d39">option::CheckArg</a> )(const Option &amp;option, bool msg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signature of functions that check if an argument is valid for a certain type of <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a>.  <a href="#a4afb7f04597f34439679509baf4b6d39"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9">option::ArgStatus</a> { <a class="el" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a353903b042e8eb0aa2f60c0043a58a7e">option::ARG_NONE</a>, 
<a class="el" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a445e08cb1747e5a22929e7ef2da43b55">option::ARG_OK</a>, 
<a class="el" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a83e0837c79c957525918111d33cab3a9">option::ARG_IGNORE</a>, 
<a class="el" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a9528e32563b795bd2930b12d0a5e382d">option::ARG_ILLEGAL</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Possible results when checking if an argument is valid for a certain <a class="el" href="df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a>. </p>
 <a href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Function , typename Stream &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/de0/namespaceoption.html#a8f43c70b443cfab0e5c00affc034fea7">option::printUsage</a> (Function *prn, Stream *stream, const Descriptor usage[], int width=80, int last_column_min_percent=50, int last_column_own_line_max_percent=75)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Syscall &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/de0/namespaceoption.html#a14761cee5fd28c4ba85de2437f72dc2e">option::printUsage</a> (Syscall *prn, int fd, const Descriptor usage[], int width=80, int last_column_min_percent=50, int last_column_own_line_max_percent=75)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Temporary &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/de0/namespaceoption.html#a33d90526c90d451b6b619ce558e8ddc9">option::printUsage</a> (const Temporary &amp;prn, const Descriptor usage[], int width=80, int last_column_min_percent=50, int last_column_own_line_max_percent=75)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/de0/namespaceoption.html#a7237545fbfc09d061d736fb19ab6f572">option::printUsage</a> (Function *prn, const Descriptor usage[], int width=80, int last_column_min_percent=50, int last_column_own_line_max_percent=75)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename OStream &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/de0/namespaceoption.html#a13564b6055a677443dfe6cdcc86875a4">option::printUsage</a> (OStream &amp;prn, const Descriptor usage[], int width=80, int last_column_min_percent=50, int last_column_own_line_max_percent=75)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Outputs a nicely formatted usage string with support for multi-column formatting and line-wrapping.  <a href="#a13564b6055a677443dfe6cdcc86875a4"></a><br/></td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class API&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/de0/namespaceoption.html#ac99aa12c5d9d6590e19cb78212eb6d63">option::Option</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This is the only file required to use The Lean Mean C++ Option Parser. Just #include it and you're set. </p>
<p>The Lean Mean C++ Option Parser handles the program's command line arguments (argc, argv). It supports the short and long <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a> formats of getopt(), getopt_long() and getopt_long_only() but has a more convenient interface. The following features set it apart from other <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a> parsers:</p>
<dl class="user"><dt><b>Highlights:</b></dt><dd><ul style="padding-left:1em;margin-left:0">
<li>
It is a header-only library. Just <code>#include &lt;<a class="el" href="../../da/d69/optionparser_8h.html" title="This is the only file required to use The Lean Mean C++ Option Parser. Just #include...">blond/optionparser.h</a>&gt;</code> and you're set. </li>
<li>
It is freestanding. There are no dependencies whatsoever, not even the C or C++ standard library. </li>
<li>
It has a usage message formatter that supports column alignment and line wrapping. This aids localization because it adapts to translated strings that are shorter or longer (even if they contain Asian wide characters). </li>
<li>
Unlike getopt() and derivatives it doesn't force you to loop through options sequentially. Instead you can access options directly like this: <ul style="margin-top:.5em">
<li>
Test for presence of a switch in the argument vector: <div class="fragment"><pre class="fragment"> <span class="keywordflow">if</span> ( options[QUIET] ) ... 
</pre></div> </li>
<li>
Evaluate --enable-foo/--disable-foo pair where the last one used wins: <div class="fragment"><pre class="fragment"> <span class="keywordflow">if</span> ( options[FOO].last()-&gt;type() == DISABLE ) ... 
</pre></div> </li>
<li>
Cumulative <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a> (-v verbose, -vv more verbose, -vvv even more verbose): <div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> verbosity = options[VERBOSE].count(); 
</pre></div> </li>
<li>
Iterate over all --file=&lt;fname&gt; arguments: <div class="fragment"><pre class="fragment"> <span class="keywordflow">for</span> (<a class="code" href="../../df/de0/namespaceoption.html#ac99aa12c5d9d6590e19cb78212eb6d63">Option</a>* opt = options[FILE]; opt; opt = opt-&gt;next())
   fname = opt-&gt;arg; ... 
</pre></div> </li>
<li>
If you really want to, you can still process all arguments in order: <div class="fragment"><pre class="fragment">   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; p.optionsCount(); ++i) {
     <a class="code" href="../../df/de0/namespaceoption.html#ac99aa12c5d9d6590e19cb78212eb6d63">Option</a>&amp; opt = buffer[i];
     <span class="keywordflow">switch</span>(opt.index()) {
       <span class="keywordflow">case</span> HELP:    ...
       <span class="keywordflow">case</span> VERBOSE: ...
       <span class="keywordflow">case</span> FILE:    fname = opt.arg; ...
       <span class="keywordflow">case</span> UNKNOWN: ...
</pre></div> </li>
</ul>
</li>
</ul>
<br/>
 Despite these features the code size remains tiny. It is smaller than <a href="http://uclibc.org">uClibc</a>'s GNU getopt() and just a couple 100 bytes larger than uClibc's SUSv3 getopt(). <br/>
 (This does not include the usage formatter, of course. But you don't have to use that.)</dd></dl>
<dl class="user"><dt><b>Download:</b></dt><dd>Tarball with examples and test programs: <a href="http://sourceforge.net/projects/optionparser/files/optionparser-1.4.tar.gz/download" style="font-size:larger;font-weight:bold">optionparser-1.4.tar.gz</a> <br/>
 Just the header (this is all you really need): &lt;a style="font-size:larger;font-weight:bold" href=<a href="http://optionparser.sourceforge.net/optionparser.h">http://optionparser.sourceforge.net/optionparser.h</a>&gt;&gt;<a class="el" href="../../da/d69/optionparser_8h.html" title="This is the only file required to use The Lean Mean C++ Option Parser. Just #include...">optionparser.h</a></dd></dl>
<dl class="user"><dt><b>Changelog:</b></dt><dd><b>Version 1.4:</b> Fixed 2 <a class="el" href="../../df/de0/namespaceoption.html#a13564b6055a677443dfe6cdcc86875a4" title="Outputs a nicely formatted usage string with support for multi-column formatting...">printUsage()</a> bugs that messed up output with small COLUMNS values <br/>
 <b>Version 1.3:</b> Compatible with Microsoft Visual C++. <br/>
 <b>Version 1.2:</b> Added <a class="el" href="../../d3/df3/classoption_1_1Option.html#a3aa2957b19ad5815873441b415d56050">Option::namelen</a> and removed the extraction of short <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a> characters into a special buffer. <br/>
 Changed <a class="el" href="../../df/dc3/structoption_1_1Arg.html#aadb5316ecbc9eb0a7f0019d14bf35ad0">Arg::Optional</a> to accept arguments if they are attached rather than separate. This is what GNU getopt() does and how POSIX recommends utilities should interpret their arguments.<br/>
 <b>Version 1.1:</b> Optional mode with argument reordering as done by GNU getopt(), so that options and non-options can be mixed. See <a class="el" href="../../d6/d83/classoption_1_1Parser.html#a6e0b5778d1cfbd6cd51240e74d01e138">Parser::parse()</a>.</dd></dl>
<dl class="user"><dt><b>Feedback:</b></dt><dd>Send questions, bug reports, feature requests etc. to: <code><b>optionparser-feedback<span id="antispam">&nbsp;(a)&nbsp;</span>lists.sourceforge.net</b></code>  <script
 type="text/javascript">document.getElementById("antispam").innerHTML="@"</script>
 </dd></dl>
<dl class="user"><dt><b>Example program:</b></dt><dd>(Note: <code><a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a>:</code>:* identifiers are links that take you to their documentation.) <div class="fragment"><pre class="fragment"><span class="preprocessor"> #error EXAMPLE SHORTENED FOR READABILITY. BETTER EXAMPLES ARE IN THE .TAR.GZ!</span>
<span class="preprocessor"></span><span class="preprocessor"> #include &lt;iostream&gt;</span>
<span class="preprocessor"> #include &lt;<a class="code" href="../../da/d69/optionparser_8h.html" title="This is the only file required to use The Lean Mean C++ Option Parser. Just #include...">blond/optionparser.h</a>&gt;</span>

 <span class="keyword">enum</span>  optionIndex { UNKNOWN, HELP, PLUS };
 <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">option::Descriptor</a> usage[] =
 {
  {UNKNOWN, 0,<span class="stringliteral">&quot;&quot;</span> , <span class="stringliteral">&quot;&quot;</span>    ,<a class="code" href="../../df/dc3/structoption_1_1Arg.html#a7fc01987899c91c6b6a1be5711a46e22" title="For options that don&amp;#39;t take an argument: Returns ARG_NONE.">option::Arg::None</a>, <span class="stringliteral">&quot;USAGE: example [options]\n\n&quot;</span>
                                             <span class="stringliteral">&quot;Options:&quot;</span> },
  {HELP,    0,<span class="stringliteral">&quot;&quot;</span> , <span class="stringliteral">&quot;help&quot;</span>,<a class="code" href="../../df/dc3/structoption_1_1Arg.html#a7fc01987899c91c6b6a1be5711a46e22" title="For options that don&amp;#39;t take an argument: Returns ARG_NONE.">option::Arg::None</a>, <span class="stringliteral">&quot;  --help  \tPrint usage and</span>
<span class="stringliteral"> exit.&quot;</span> },
  {PLUS,    0,<span class="stringliteral">&quot;p&quot;</span>, <span class="stringliteral">&quot;plus&quot;</span>,<a class="code" href="../../df/dc3/structoption_1_1Arg.html#a7fc01987899c91c6b6a1be5711a46e22" title="For options that don&amp;#39;t take an argument: Returns ARG_NONE.">option::Arg::None</a>, <span class="stringliteral">&quot;  --plus, -p  \tIncrement</span>
<span class="stringliteral"> count.&quot;</span> },
  {UNKNOWN, 0,<span class="stringliteral">&quot;&quot;</span> ,  <span class="stringliteral">&quot;&quot;</span>   ,<a class="code" href="../../df/dc3/structoption_1_1Arg.html#a7fc01987899c91c6b6a1be5711a46e22" title="For options that don&amp;#39;t take an argument: Returns ARG_NONE.">option::Arg::None</a>, <span class="stringliteral">&quot;\nExamples:\n&quot;</span>
                                             <span class="stringliteral">&quot;  example --unknown --</span>
<span class="stringliteral"> --this_is_no_option\n&quot;</span>
                                             <span class="stringliteral">&quot;  example -unk --plus -ppp file1</span>
<span class="stringliteral"> file2\n&quot;</span> },
  {0,0,0,0,0,0}
 };

 <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])
 {
   argc-=(argc&gt;0); argv+=(argc&gt;0); <span class="comment">// skip program name argv[0] if present</span>
   <a class="code" href="../../d8/de3/structoption_1_1Stats.html" title="Determines the minimum lengths of the buffer and options arrays used for Parser.">option::Stats</a>  stats(usage, argc, argv);
   <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">option::Option</a> options[stats.options_max], buffer[stats.buffer_max];
   <a class="code" href="../../d6/d83/classoption_1_1Parser.html" title="Checks argument vectors for validity and parses them into data structures that are...">option::Parser</a> parse(usage, argc, argv, options, buffer);

   <span class="keywordflow">if</span> (parse.error())
     <span class="keywordflow">return</span> 1;

   <span class="keywordflow">if</span> (options[HELP] || argc == 0) {
     <a class="code" href="../../df/de0/namespaceoption.html#a13564b6055a677443dfe6cdcc86875a4" title="Outputs a nicely formatted usage string with support for multi-column formatting...">option::printUsage</a>(std::cout, usage);
     <span class="keywordflow">return</span> 0;
   }

   std::cout &lt;&lt; <span class="stringliteral">&quot;--plus count: &quot;</span> &lt;&lt;
     options[PLUS].<a class="code" href="../../d3/df3/classoption_1_1Option.html#a8a632dcd89af60fe0806deb756c08f14" title="Returns the number of times this Option (or others with the same Descriptor::index)...">count</a>() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;

   <span class="keywordflow">for</span> (<a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">option::Option</a>* opt = options[UNKNOWN]; opt; opt = opt-&gt;<a class="code" href="../../d3/df3/classoption_1_1Option.html#a59ae9aed505f4d410633bb36478a32be" title="Returns a pointer to the next element of the linked list or NULL if called on last()...">next</a>())
     std::cout &lt;&lt; <span class="stringliteral">&quot;Unknown option: &quot;</span> &lt;&lt; opt-&gt;name &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;

   for (<span class="keywordtype">int</span> i = 0; i &lt; parse.nonOptionsCount(); ++i)
     std::cout &lt;&lt; <span class="stringliteral">&quot;Non-option #&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; parse.nonOption(i) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
 }
</pre></div></dd></dl>
<dl class="user"><dt><b>Option syntax:</b></dt><dd><ul>
<li>The Lean Mean C++ Option Parser follows POSIX <code>getopt()</code> conventions and supports GNU-style <code>getopt_long()</code> long options as well as Perl-style single-minus long options (<code>getopt_long_only()</code>). </li>
<li>short options have the format <code>-X</code> where <code>X</code> is any character that fits in a char. </li>
<li>short options can be grouped, i.e. <code>-X -Y</code> is equivalent to <code>-XY</code>. </li>
<li>a short <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a> may take an argument either separate (<code>-X foo</code>) or attached (<code>-Xfoo</code>). You can make the parser accept the additional format <code>-X=foo</code> by registering <code>X</code> as a long <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a> (in addition to being a short <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a>) and enabling single-minus long options. </li>
<li>an argument-taking short <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a> may be grouped if it is the last in the group, e.g. <code>-ABCXfoo</code> or <code> -ABCX foo </code> (<code>foo</code> is the argument to the <code>-X</code> <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a>). </li>
<li>a lone minus character <code>'-'</code> is not treated as an <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a>. It is customarily used where a file name is expected to refer to stdin or stdout. </li>
<li>long options have the format <code>--option-name</code>. </li>
<li>the option-name of a long <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a> can be anything and include any characters. Even <code>=</code> characters will work, but don't do that. </li>
<li>[optional] long options may be abbreviated as long as the abbreviation is unambiguous. You can set a minimum length for abbreviations. </li>
<li>[optional] long options may begin with a single minus. The double minus form is always accepted, too. </li>
<li>a long <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a> may take an argument either separate (<code> --option arg </code>) or attached (<code> --option=arg </code>). In the attached form the equals sign is mandatory. </li>
<li>an empty string can be passed as an attached long <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a> argument: <code> --option-name= </code>. Note the distinction between an empty string as argument and no argument at all. </li>
<li>an empty string is permitted as separate argument to both long and short options. </li>
<li>Arguments to both short and long options may start with a <code>'-'</code> character. E.g. <code> -X-X </code>, <code>-X -X</code> or <code> --long-X=-X </code>. If <code>-X</code> and <code>--long-X</code> take an argument, that argument will be <code>"-X"</code> in all 3 cases. </li>
<li>If using the built-in <a class="el" href="../../df/dc3/structoption_1_1Arg.html#aadb5316ecbc9eb0a7f0019d14bf35ad0">Arg::Optional</a>, optional arguments must be attached. </li>
<li>the special <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a> <code>--</code> (i.e. without a name) terminates the list of options. Everything that follows is a non-option argument, even if it starts with a <code>'-'</code> character. The <code>--</code> itself will not appear in the parse results. </li>
<li>the first argument that doesn't start with <code>'-'</code> or <code>'--'</code> and does not belong to a preceding argument-taking <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a>, will terminate the <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a> list and is the first non-option argument. All following command line arguments are treated as non-option arguments, even if they start with <code>'-'</code> . <br/>
 NOTE: This behaviour is mandated by POSIX, but GNU getopt() only honours this if it is explicitly requested (e.g. by setting POSIXLY_CORRECT). <br/>
 You can enable the GNU behaviour by passing <code>true</code> as first argument to e.g. <a class="el" href="../../d6/d83/classoption_1_1Parser.html#a6e0b5778d1cfbd6cd51240e74d01e138">Parser::parse()</a>. </li>
<li>Arguments that look like options (i.e. <code>'-'</code> followed by at least 1 character) but aren't, are NOT treated as non-option arguments. They are treated as unknown options and are collected into a list of unknown options for error reporting. <br/>
 This means that in order to pass a first non-option argument beginning with the minus character it is required to use the <code>--</code> special <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a>, e.g. <div class="fragment"><pre class="fragment">     program -x -- --strange-filename
</pre></div> In this example, <code>--strange-filename</code> is a non-option argument. If the <code>--</code> were omitted, it would be treated as an unknown <a class="el" href="../../df/de0/namespaceoption.html" title="The namespace of The Lean Mean C++ Option Parser.">option</a>. <br/>
 See <a class="el" href="../../dc/dfe/structoption_1_1Descriptor.html#a470c449dfa894c9bfda2dae026142b4b">option::Descriptor::longopt</a> for information on how to collect unknown options. </li>
</ul>
</dd></dl>

<p>Definition in file <a class="el" href="../../da/d69/optionparser_8h_source.html">optionparser.h</a>.</p>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 5 Sep 2016 for Beam Longitudinal Dynamics code (BLonD) by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
