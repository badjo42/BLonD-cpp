<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Beam Longitudinal Dynamics code (BLonD): optionparser.h Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='../../open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='../../closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='../../closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="../../files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="../../globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>optionparser.h</h1><a href="../../da/d69/optionparser_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">* The Lean Mean C++ Option Parser</span>
<a name="l00003"></a>00003 <span class="comment">*</span>
<a name="l00004"></a>00004 <span class="comment">* Copyright (C) 2012 Matthias S. Benkmann</span>
<a name="l00005"></a>00005 <span class="comment">*</span>
<a name="l00006"></a>00006 <span class="comment">* The &quot;Software&quot; in the following 2 paragraphs refers to this file containing</span>
<a name="l00007"></a>00007 <span class="comment">* the code to The Lean Mean C++ Option Parser.</span>
<a name="l00008"></a>00008 <span class="comment">* The &quot;Software&quot; does NOT refer to any other files which you</span>
<a name="l00009"></a>00009 <span class="comment">* may have received alongside this file (e.g. as part of a larger project that</span>
<a name="l00010"></a>00010 <span class="comment">* incorporates The Lean Mean C++ Option Parser).</span>
<a name="l00011"></a>00011 <span class="comment">*</span>
<a name="l00012"></a>00012 <span class="comment">* Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<a name="l00013"></a>00013 <span class="comment">* of this software, to deal in the Software without restriction, including</span>
<a name="l00014"></a>00014 <span class="comment">* without limitation the rights to use, copy, modify, merge, publish,</span>
<a name="l00015"></a>00015 <span class="comment">* distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<a name="l00016"></a>00016 <span class="comment">* persons to whom the Software is furnished to do so, subject to the following</span>
<a name="l00017"></a>00017 <span class="comment">* conditions:</span>
<a name="l00018"></a>00018 <span class="comment">* The above copyright notice and this permission notice shall be included in</span>
<a name="l00019"></a>00019 <span class="comment">* all copies or substantial portions of the Software.</span>
<a name="l00020"></a>00020 <span class="comment">*</span>
<a name="l00021"></a>00021 <span class="comment">* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<a name="l00022"></a>00022 <span class="comment">* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<a name="l00023"></a>00023 <span class="comment">* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<a name="l00024"></a>00024 <span class="comment">* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<a name="l00025"></a>00025 <span class="comment">* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<a name="l00026"></a>00026 <span class="comment">* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<a name="l00027"></a>00027 <span class="comment">* SOFTWARE.</span>
<a name="l00028"></a>00028 <span class="comment">*/</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="comment">/*</span>
<a name="l00031"></a>00031 <span class="comment">* NOTE: It is recommended that you read the processed HTML doxygen</span>
<a name="l00032"></a>00032 <span class="comment">* documentation</span>
<a name="l00033"></a>00033 <span class="comment">* rather than this source. If you don&apos;t know doxygen, it&apos;s like javadoc for</span>
<a name="l00034"></a>00034 <span class="comment">* C++.</span>
<a name="l00035"></a>00035 <span class="comment">* If you don&apos;t want to install doxygen you can find a copy of the processed</span>
<a name="l00036"></a>00036 <span class="comment">* documentation at</span>
<a name="l00037"></a>00037 <span class="comment">*</span>
<a name="l00038"></a>00038 <span class="comment">* http://optionparser.sourceforge.net/</span>
<a name="l00039"></a>00039 <span class="comment">*</span>
<a name="l00040"></a>00040 <span class="comment">*/</span>
<a name="l00041"></a>00041 
<a name="l00272"></a>00272 <span class="preprocessor">#ifndef OPTIONPARSER_H_</span>
<a name="l00273"></a>00273 <span class="preprocessor"></span><span class="preprocessor">#define OPTIONPARSER_H_</span>
<a name="l00274"></a>00274 <span class="preprocessor"></span>
<a name="l00275"></a><a class="code" href="../../df/de0/namespaceoption.html">00275</a> <span class="keyword">namespace </span>option {
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00278"></a>00278 <span class="preprocessor"></span><span class="preprocessor">#include &lt;intrin.h&gt;</span>
<a name="l00279"></a>00279 <span class="preprocessor">#pragma intrinsic(_BitScanReverse)</span>
<a name="l00280"></a>00280 <span class="preprocessor"></span>    <span class="keyword">struct </span><a class="code" href="../../de/df0/utilities_8h.html#ad8ce4efaa307683d3d763b37b4711c53">API</a> MSC_Builtin_CLZ {
<a name="l00281"></a>00281         <span class="keyword">static</span> <span class="keywordtype">int</span> builtin_clz(<span class="keywordtype">unsigned</span> x) {
<a name="l00282"></a>00282             <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> index;
<a name="l00283"></a>00283             _BitScanReverse(&amp;index, x);
<a name="l00284"></a>00284             <span class="keywordflow">return</span> 32 -
<a name="l00285"></a>00285                    index; <span class="comment">// int is always 32bit on Windows, even for target x64</span>
<a name="l00286"></a>00286         }
<a name="l00287"></a>00287     };
<a name="l00288"></a>00288 <span class="preprocessor">#define __builtin_clz(x) MSC_Builtin_CLZ::builtin_clz(x)</span>
<a name="l00289"></a>00289 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00290"></a>00290 <span class="preprocessor"></span>
<a name="l00291"></a><a class="code" href="../../df/de0/namespaceoption.html#ac99aa12c5d9d6590e19cb78212eb6d63">00291</a>     <span class="keyword">class </span><a class="code" href="../../de/df0/utilities_8h.html#ad8ce4efaa307683d3d763b37b4711c53">API</a> <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>;
<a name="l00292"></a>00292 
<a name="l00301"></a><a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9">00301</a>     <span class="keyword">enum</span> <a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9" title="Possible results when checking if an argument is valid for a certain option.">ArgStatus</a> {
<a name="l00303"></a><a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a353903b042e8eb0aa2f60c0043a58a7e">00303</a>         <a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a353903b042e8eb0aa2f60c0043a58a7e" title="The option does not take an argument.">ARG_NONE</a>,
<a name="l00305"></a><a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a445e08cb1747e5a22929e7ef2da43b55">00305</a>         <a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a445e08cb1747e5a22929e7ef2da43b55" title="The argument is acceptable for the option.">ARG_OK</a>,
<a name="l00308"></a><a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a83e0837c79c957525918111d33cab3a9">00308</a>         <a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a83e0837c79c957525918111d33cab3a9" title="The argument is not acceptable but that&amp;#39;s non-fatal because the option&amp;#39;s...">ARG_IGNORE</a>,
<a name="l00310"></a><a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a9528e32563b795bd2930b12d0a5e382d">00310</a>         <a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a9528e32563b795bd2930b12d0a5e382d" title="The argument is not acceptable and that&amp;#39;s fatal.">ARG_ILLEGAL</a>
<a name="l00311"></a>00311     };
<a name="l00312"></a>00312 
<a name="l00347"></a><a class="code" href="../../df/de0/namespaceoption.html#a4afb7f04597f34439679509baf4b6d39">00347</a>     <span class="keyword">typedef</span> <a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9" title="Possible results when checking if an argument is valid for a certain option.">ArgStatus</a> (*<a class="code" href="../../df/de0/namespaceoption.html#a4afb7f04597f34439679509baf4b6d39" title="Signature of functions that check if an argument is valid for a certain type of option...">CheckArg</a>)(<span class="keyword">const</span> <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>&amp; option, <span class="keywordtype">bool</span> msg);
<a name="l00348"></a>00348 
<a name="l00373"></a><a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html">00373</a>     <span class="keyword">struct </span><a class="code" href="../../de/df0/utilities_8h.html#ad8ce4efaa307683d3d763b37b4711c53">API</a> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> {
<a name="l00403"></a><a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html#a1fee8ac44f529c99ac2b1149b4c391b1">00403</a>         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> index;
<a name="l00404"></a>00404 
<a name="l00413"></a><a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html#a1b220dabd8aad075fa441a80f9b9343c">00413</a>         <span class="keyword">const</span> <span class="keywordtype">int</span> type;
<a name="l00414"></a>00414 
<a name="l00429"></a><a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html#a0dba4ccca59c19d6ed4081391fca5adb">00429</a>         <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> shortopt;
<a name="l00430"></a>00430 
<a name="l00476"></a><a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html#a470c449dfa894c9bfda2dae026142b4b">00476</a>         <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> longopt;
<a name="l00477"></a>00477 
<a name="l00491"></a><a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html#aa5d675dba0214a4abd73007ff163cc67">00491</a>         <span class="keyword">const</span> <a class="code" href="../../df/de0/namespaceoption.html#a4afb7f04597f34439679509baf4b6d39" title="Signature of functions that check if an argument is valid for a certain type of option...">CheckArg</a> check_arg;
<a name="l00492"></a>00492 
<a name="l00512"></a><a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html#a9045b19311533e1b8a08645d57149c79">00512</a>         <span class="keyword">const</span> <span class="keywordtype">char</span>* help;
<a name="l00513"></a>00513     };
<a name="l00514"></a>00514 
<a name="l00537"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html">00537</a>     <span class="keyword">class </span><a class="code" href="../../de/df0/utilities_8h.html#ad8ce4efaa307683d3d763b37b4711c53">API</a> <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> {
<a name="l00538"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#ab4c101fe086777f62ebba72c3e74fda9">00538</a>         <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* next_;
<a name="l00539"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#afd8886a5db01957949ce9db38a1f19da">00539</a>         <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* prev_;
<a name="l00540"></a>00540 
<a name="l00541"></a>00541       <span class="keyword">public</span>:
<a name="l00563"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#af8d664a7b5de1425008b1812a90a0c23">00563</a>         <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a>* desc;
<a name="l00564"></a>00564 
<a name="l00584"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#a02a76b4896abd22d0ba8514362261de9">00584</a>         <span class="keyword">const</span> <span class="keywordtype">char</span>* name;
<a name="l00585"></a>00585 
<a name="l00593"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#a402be734987458364b0f473acae36238">00593</a>         <span class="keyword">const</span> <span class="keywordtype">char</span>* arg;
<a name="l00594"></a>00594 
<a name="l00625"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#a3aa2957b19ad5815873441b415d56050">00625</a>         <span class="keywordtype">int</span> namelen;
<a name="l00626"></a>00626 
<a name="l00651"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#a6560fa0526e2affd87d5a10622336af4">00651</a>         <span class="keywordtype">int</span> <a class="code" href="../../d3/df3/classoption_1_1Option.html#a6560fa0526e2affd87d5a10622336af4" title="Returns Descriptor::type of this Option&amp;#39;s Descriptor, or 0 if this Option is...">type</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> desc == 0 ? 0 : desc-&gt;type; }
<a name="l00652"></a>00652 
<a name="l00658"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#ac0acba91bbfcca0c35cfc54f197b15d2">00658</a>         <span class="keywordtype">int</span> <a class="code" href="../../d3/df3/classoption_1_1Option.html#ac0acba91bbfcca0c35cfc54f197b15d2" title="Returns Descriptor::index of this Option&amp;#39;s Descriptor, or -1 if this Option is...">index</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> desc == 0 ? -1 : (int)desc-&gt;index; }
<a name="l00659"></a>00659 
<a name="l00675"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#a8a632dcd89af60fe0806deb756c08f14">00675</a>         <span class="keywordtype">int</span> <a class="code" href="../../d3/df3/classoption_1_1Option.html#a8a632dcd89af60fe0806deb756c08f14" title="Returns the number of times this Option (or others with the same Descriptor::index)...">count</a>() {
<a name="l00676"></a>00676             <span class="keywordtype">int</span> <a class="code" href="../../da/db5/namespaceconstant.html#a2ba393c8a725b9748a9fce5138d53dd8">c</a> = (desc == 0 ? 0 : 1);
<a name="l00677"></a>00677             <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* p = first();
<a name="l00678"></a>00678             <span class="keywordflow">while</span> (!p-&gt;<a class="code" href="../../d3/df3/classoption_1_1Option.html#ad60789506c3df60dedd4a006af56ece9" title="Returns true iff this is the last element of the linked list.">isLast</a>()) {
<a name="l00679"></a>00679                 ++c;
<a name="l00680"></a>00680                 p = p-&gt;<a class="code" href="../../d3/df3/classoption_1_1Option.html#ab4c101fe086777f62ebba72c3e74fda9">next_</a>;
<a name="l00681"></a>00681             };
<a name="l00682"></a>00682             <span class="keywordflow">return</span> c;
<a name="l00683"></a>00683         }
<a name="l00684"></a>00684 
<a name="l00694"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#aee7a11f90cf4b70f65fb6bdf4db2c922">00694</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d3/df3/classoption_1_1Option.html#aee7a11f90cf4b70f65fb6bdf4db2c922" title="Returns true iff this is the first element of the linked list.">isFirst</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> isTagged(prev_); }
<a name="l00695"></a>00695 
<a name="l00705"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#ad60789506c3df60dedd4a006af56ece9">00705</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d3/df3/classoption_1_1Option.html#ad60789506c3df60dedd4a006af56ece9" title="Returns true iff this is the last element of the linked list.">isLast</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> isTagged(next_); }
<a name="l00706"></a>00706 
<a name="l00721"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#abb4e13cd7c90999c8a6b1f871cece283">00721</a>         <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* <a class="code" href="../../d3/df3/classoption_1_1Option.html#abb4e13cd7c90999c8a6b1f871cece283" title="Returns a pointer to the first element of the linked list.">first</a>() {
<a name="l00722"></a>00722             <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* p = <span class="keyword">this</span>;
<a name="l00723"></a>00723             <span class="keywordflow">while</span> (!p-&gt;<a class="code" href="../../d3/df3/classoption_1_1Option.html#aee7a11f90cf4b70f65fb6bdf4db2c922" title="Returns true iff this is the first element of the linked list.">isFirst</a>())
<a name="l00724"></a>00724                 p = p-&gt;<a class="code" href="../../d3/df3/classoption_1_1Option.html#afd8886a5db01957949ce9db38a1f19da">prev_</a>;
<a name="l00725"></a>00725             <span class="keywordflow">return</span> p;
<a name="l00726"></a>00726         }
<a name="l00727"></a>00727 
<a name="l00750"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#afe2aff68191e55b59c53fac3dbbcd7c3">00750</a>         <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* <a class="code" href="../../d3/df3/classoption_1_1Option.html#afe2aff68191e55b59c53fac3dbbcd7c3" title="Returns a pointer to the last element of the linked list.">last</a>() { <span class="keywordflow">return</span> first()-&gt;<a class="code" href="../../d3/df3/classoption_1_1Option.html#a1226e45dc2de30f269b2aff1784bbee7" title="Returns a pointer to the previous element of the linked list with wrap-around from...">prevwrap</a>(); }
<a name="l00751"></a>00751 
<a name="l00763"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#a4d12001a91b0b35cf47437d0c60d2b52">00763</a>         <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* <a class="code" href="../../d3/df3/classoption_1_1Option.html#a4d12001a91b0b35cf47437d0c60d2b52" title="Returns a pointer to the previous element of the linked list or NULL if called on...">prev</a>() { <span class="keywordflow">return</span> isFirst() ? 0 : prev_; }
<a name="l00764"></a>00764 
<a name="l00776"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#a1226e45dc2de30f269b2aff1784bbee7">00776</a>         <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* <a class="code" href="../../d3/df3/classoption_1_1Option.html#a1226e45dc2de30f269b2aff1784bbee7" title="Returns a pointer to the previous element of the linked list with wrap-around from...">prevwrap</a>() { <span class="keywordflow">return</span> untag(prev_); }
<a name="l00777"></a>00777 
<a name="l00789"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#a59ae9aed505f4d410633bb36478a32be">00789</a>         <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* <a class="code" href="../../d3/df3/classoption_1_1Option.html#a59ae9aed505f4d410633bb36478a32be" title="Returns a pointer to the next element of the linked list or NULL if called on last()...">next</a>() { <span class="keywordflow">return</span> isLast() ? 0 : next_; }
<a name="l00790"></a>00790 
<a name="l00802"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#ae8d8c058af3c781cb1d444998df48fef">00802</a>         <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* <a class="code" href="../../d3/df3/classoption_1_1Option.html#ae8d8c058af3c781cb1d444998df48fef" title="Returns a pointer to the next element of the linked list with wrap-around from last()...">nextwrap</a>() { <span class="keywordflow">return</span> untag(next_); }
<a name="l00803"></a>00803 
<a name="l00817"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#a59030822a1ec4e667e6c288d7e5ec961">00817</a>         <span class="keywordtype">void</span> <a class="code" href="../../d3/df3/classoption_1_1Option.html#a59030822a1ec4e667e6c288d7e5ec961" title="Makes new_last the new last() by chaining it into the list after last().">append</a>(<a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* new_last) {
<a name="l00818"></a>00818             <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* p = last();
<a name="l00819"></a>00819             <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* f = first();
<a name="l00820"></a>00820             p-&gt;<a class="code" href="../../d3/df3/classoption_1_1Option.html#ab4c101fe086777f62ebba72c3e74fda9">next_</a> = new_last;
<a name="l00821"></a>00821             new_last-&gt;<a class="code" href="../../d3/df3/classoption_1_1Option.html#afd8886a5db01957949ce9db38a1f19da">prev_</a> = p;
<a name="l00822"></a>00822             new_last-&gt;<a class="code" href="../../d3/df3/classoption_1_1Option.html#ab4c101fe086777f62ebba72c3e74fda9">next_</a> = tag(f);
<a name="l00823"></a>00823             f-&gt;<a class="code" href="../../d3/df3/classoption_1_1Option.html#afd8886a5db01957949ce9db38a1f19da">prev_</a> = tag(new_last);
<a name="l00824"></a>00824         }
<a name="l00825"></a>00825 
<a name="l00843"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#aaaeedf023bc3f5eee0b199c64d8fe1ec">00843</a>         operator const Option*()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> desc ? <span class="keyword">this</span> : 0; }
<a name="l00844"></a>00844 
<a name="l00861"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#ac5b9235d79208035d97e41fe17ba04d6">00861</a>         operator Option*() { <span class="keywordflow">return</span> desc ? <span class="keyword">this</span> : 0; }
<a name="l00862"></a>00862 
<a name="l00868"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#aa2810152fc23b14175b115d1a7d38095">00868</a>         <a class="code" href="../../d3/df3/classoption_1_1Option.html#aa2810152fc23b14175b115d1a7d38095" title="Creates a new Option that is a one-element linked list and has NULL desc, name, arg...">Option</a>() : desc(0), name(0), arg(0), namelen(0) {
<a name="l00869"></a>00869             prev_ = tag(<span class="keyword">this</span>);
<a name="l00870"></a>00870             next_ = tag(<span class="keyword">this</span>);
<a name="l00871"></a>00871         }
<a name="l00872"></a>00872 
<a name="l00884"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#a385221e2a8f37c548f0d5777bfddb216">00884</a>         <a class="code" href="../../d3/df3/classoption_1_1Option.html#a385221e2a8f37c548f0d5777bfddb216" title="Creates a new Option that is a one-element linked list and has the given values for...">Option</a>(<span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a>* desc_, <span class="keyword">const</span> <span class="keywordtype">char</span>* name_, <span class="keyword">const</span> <span class="keywordtype">char</span>* arg_) {
<a name="l00885"></a>00885             init(desc_, name_, arg_);
<a name="l00886"></a>00886         }
<a name="l00887"></a>00887 
<a name="l00894"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#adb4b44f3778df8f28a04c48bd1b4a72b">00894</a>         <span class="keywordtype">void</span> <a class="code" href="../../d3/df3/classoption_1_1Option.html#adb4b44f3778df8f28a04c48bd1b4a72b" title="Makes *this a copy of orig except for the linked list pointers.">operator=</a>(<span class="keyword">const</span> <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>&amp; orig) {
<a name="l00895"></a>00895             init(orig.<a class="code" href="../../d3/df3/classoption_1_1Option.html#af8d664a7b5de1425008b1812a90a0c23" title="Pointer to this Option&amp;#39;s Descriptor.">desc</a>, orig.<a class="code" href="../../d3/df3/classoption_1_1Option.html#a02a76b4896abd22d0ba8514362261de9" title="The name of the option as used on the command line.">name</a>, orig.<a class="code" href="../../d3/df3/classoption_1_1Option.html#a402be734987458364b0f473acae36238" title="Pointer to this Option&amp;#39;s argument (if any).">arg</a>);
<a name="l00896"></a>00896         }
<a name="l00897"></a>00897 
<a name="l00904"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#a4053240fecad1a3b1d8e4dc06b7aa8c4">00904</a>         <a class="code" href="../../d3/df3/classoption_1_1Option.html#a4053240fecad1a3b1d8e4dc06b7aa8c4" title="Makes *this a copy of orig except for the linked list pointers.">Option</a>(<span class="keyword">const</span> <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>&amp; orig) { init(orig.<a class="code" href="../../d3/df3/classoption_1_1Option.html#af8d664a7b5de1425008b1812a90a0c23" title="Pointer to this Option&amp;#39;s Descriptor.">desc</a>, orig.<a class="code" href="../../d3/df3/classoption_1_1Option.html#a02a76b4896abd22d0ba8514362261de9" title="The name of the option as used on the command line.">name</a>, orig.<a class="code" href="../../d3/df3/classoption_1_1Option.html#a402be734987458364b0f473acae36238" title="Pointer to this Option&amp;#39;s argument (if any).">arg</a>); }
<a name="l00905"></a>00905 
<a name="l00906"></a>00906       <span class="keyword">private</span>:
<a name="l00918"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#a92066af01f531c27f85e020c40c14078">00918</a>         <span class="keywordtype">void</span> init(<span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a>* desc_, <span class="keyword">const</span> <span class="keywordtype">char</span>* name_,
<a name="l00919"></a>00919                   <span class="keyword">const</span> <span class="keywordtype">char</span>* arg_) {
<a name="l00920"></a>00920             desc = desc_;
<a name="l00921"></a>00921             name = name_;
<a name="l00922"></a>00922             arg = arg_;
<a name="l00923"></a>00923             prev_ = tag(<span class="keyword">this</span>);
<a name="l00924"></a>00924             next_ = tag(<span class="keyword">this</span>);
<a name="l00925"></a>00925             namelen = 0;
<a name="l00926"></a>00926             <span class="keywordflow">if</span> (name == 0)
<a name="l00927"></a>00927                 <span class="keywordflow">return</span>;
<a name="l00928"></a>00928             namelen = 1;
<a name="l00929"></a>00929             <span class="keywordflow">if</span> (name[0] != <span class="charliteral">&apos;-&apos;</span>)
<a name="l00930"></a>00930                 <span class="keywordflow">return</span>;
<a name="l00931"></a>00931             <span class="keywordflow">while</span> (name[namelen] != 0 &amp;&amp; name[namelen] != <span class="charliteral">&apos;=&apos;</span>)
<a name="l00932"></a>00932                 ++namelen;
<a name="l00933"></a>00933         }
<a name="l00934"></a>00934 
<a name="l00935"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#a4622754149f7502c434f5f9fee47d2bb">00935</a>         <span class="keyword">static</span> <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* <a class="code" href="../../d3/df3/classoption_1_1Option.html#a4622754149f7502c434f5f9fee47d2bb">tag</a>(<a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* ptr) {
<a name="l00936"></a>00936             <span class="keywordflow">return</span> (<a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>*)((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> long)ptr | 1);
<a name="l00937"></a>00937         }
<a name="l00938"></a>00938 
<a name="l00939"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#a956e899e96ab6f99617d473ad4246c23">00939</a>         <span class="keyword">static</span> <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* <a class="code" href="../../d3/df3/classoption_1_1Option.html#a956e899e96ab6f99617d473ad4246c23">untag</a>(<a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* ptr) {
<a name="l00940"></a>00940             <span class="keywordflow">return</span> (<a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>*)((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> long)ptr &amp; ~1ull);
<a name="l00941"></a>00941         }
<a name="l00942"></a>00942 
<a name="l00943"></a><a class="code" href="../../d3/df3/classoption_1_1Option.html#a1d717f053449a3b35e22a20613188ef3">00943</a>         <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="../../d3/df3/classoption_1_1Option.html#a1d717f053449a3b35e22a20613188ef3">isTagged</a>(<a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* ptr) {
<a name="l00944"></a>00944             <span class="keywordflow">return</span> ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span>)ptr &amp; 1);
<a name="l00945"></a>00945         }
<a name="l00946"></a>00946     };
<a name="l00947"></a>00947 
<a name="l01010"></a><a class="code" href="../../df/dc3/structoption_1_1Arg.html">01010</a>     <span class="keyword">struct </span><a class="code" href="../../de/df0/utilities_8h.html#ad8ce4efaa307683d3d763b37b4711c53">API</a> <a class="code" href="../../df/dc3/structoption_1_1Arg.html" title="Functions for checking the validity of option arguments.">Arg</a> {
<a name="l01012"></a><a class="code" href="../../df/dc3/structoption_1_1Arg.html#a7fc01987899c91c6b6a1be5711a46e22">01012</a>         <span class="keyword">static</span> <a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9" title="Possible results when checking if an argument is valid for a certain option.">ArgStatus</a> <a class="code" href="../../df/dc3/structoption_1_1Arg.html#a7fc01987899c91c6b6a1be5711a46e22" title="For options that don&amp;#39;t take an argument: Returns ARG_NONE.">None</a>(<span class="keyword">const</span> <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>&amp;, <span class="keywordtype">bool</span>) { <span class="keywordflow">return</span> <a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a353903b042e8eb0aa2f60c0043a58a7e" title="The option does not take an argument.">ARG_NONE</a>; }
<a name="l01013"></a>01013 
<a name="l01016"></a><a class="code" href="../../df/dc3/structoption_1_1Arg.html#aadb5316ecbc9eb0a7f0019d14bf35ad0">01016</a>         <span class="keyword">static</span> <a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9" title="Possible results when checking if an argument is valid for a certain option.">ArgStatus</a> <a class="code" href="../../df/dc3/structoption_1_1Arg.html#aadb5316ecbc9eb0a7f0019d14bf35ad0" title="Returns ARG_OK if the argument is attached and ARG_IGNORE otherwise.">Optional</a>(<span class="keyword">const</span> <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>&amp; option, <span class="keywordtype">bool</span>) {
<a name="l01017"></a>01017             <span class="keywordflow">if</span> (option.<a class="code" href="../../d3/df3/classoption_1_1Option.html#a402be734987458364b0f473acae36238" title="Pointer to this Option&amp;#39;s argument (if any).">arg</a> &amp;&amp; option.<a class="code" href="../../d3/df3/classoption_1_1Option.html#a02a76b4896abd22d0ba8514362261de9" title="The name of the option as used on the command line.">name</a>[option.<a class="code" href="../../d3/df3/classoption_1_1Option.html#a3aa2957b19ad5815873441b415d56050" title="The length of the option name.">namelen</a>] != 0)
<a name="l01018"></a>01018                 <span class="keywordflow">return</span> <a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a445e08cb1747e5a22929e7ef2da43b55" title="The argument is acceptable for the option.">ARG_OK</a>;
<a name="l01019"></a>01019             <span class="keywordflow">else</span>
<a name="l01020"></a>01020                 <span class="keywordflow">return</span> <a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a83e0837c79c957525918111d33cab3a9" title="The argument is not acceptable but that&amp;#39;s non-fatal because the option&amp;#39;s...">ARG_IGNORE</a>;
<a name="l01021"></a>01021         }
<a name="l01022"></a>01022     };
<a name="l01023"></a>01023 
<a name="l01038"></a><a class="code" href="../../d8/de3/structoption_1_1Stats.html">01038</a>     <span class="keyword">struct </span><a class="code" href="../../de/df0/utilities_8h.html#ad8ce4efaa307683d3d763b37b4711c53">API</a> <a class="code" href="../../d8/de3/structoption_1_1Stats.html" title="Determines the minimum lengths of the buffer and options arrays used for Parser.">Stats</a> {
<a name="l01051"></a><a class="code" href="../../d8/de3/structoption_1_1Stats.html#a2c9a7b4174f91ba8bcadaa9ad6f0db06">01051</a>         <span class="keywordtype">unsigned</span> buffer_max;
<a name="l01052"></a>01052 
<a name="l01069"></a><a class="code" href="../../d8/de3/structoption_1_1Stats.html#a8121787feb1c7db84fca3ccb012b0473">01069</a>         <span class="keywordtype">unsigned</span> options_max;
<a name="l01070"></a>01070 
<a name="l01075"></a><a class="code" href="../../d8/de3/structoption_1_1Stats.html#a8660722c76e65d9328313fb360bdd282">01075</a>         <a class="code" href="../../d8/de3/structoption_1_1Stats.html" title="Determines the minimum lengths of the buffer and options arrays used for Parser.">Stats</a>()
<a name="l01076"></a>01076             : buffer_max(1), options_max(1) <span class="comment">// 1 more than necessary as sentinel</span>
<a name="l01077"></a>01077         {}
<a name="l01078"></a>01078 
<a name="l01090"></a><a class="code" href="../../d8/de3/structoption_1_1Stats.html#a71373ec2b28842f45593e4405f7bc8ec">01090</a>         <a class="code" href="../../d8/de3/structoption_1_1Stats.html" title="Determines the minimum lengths of the buffer and options arrays used for Parser.">Stats</a>(<span class="keywordtype">bool</span> gnu, <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv,
<a name="l01091"></a>01091               <span class="keywordtype">int</span> min_abbr_len = 0, <span class="comment">//</span>
<a name="l01092"></a>01092               <span class="keywordtype">bool</span> single_minus_longopt = <span class="keyword">false</span>)
<a name="l01093"></a>01093             : buffer_max(1), options_max(1) <span class="comment">// 1 more than necessary as sentinel</span>
<a name="l01094"></a>01094         {
<a name="l01095"></a>01095             add(gnu, usage, argc, argv, min_abbr_len, single_minus_longopt);
<a name="l01096"></a>01096         }
<a name="l01097"></a>01097 
<a name="l01099"></a><a class="code" href="../../d8/de3/structoption_1_1Stats.html#a43ec104fdb0b8ae6148d04f3ad3d3a75">01099</a>         <a class="code" href="../../d8/de3/structoption_1_1Stats.html" title="Determines the minimum lengths of the buffer and options arrays used for Parser.">Stats</a>(<span class="keywordtype">bool</span> gnu, <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv,
<a name="l01100"></a>01100               <span class="keywordtype">int</span> min_abbr_len = 0, <span class="comment">//</span>
<a name="l01101"></a>01101               <span class="keywordtype">bool</span> single_minus_longopt = <span class="keyword">false</span>)
<a name="l01102"></a>01102             : buffer_max(1), options_max(1) <span class="comment">// 1 more than necessary as sentinel</span>
<a name="l01103"></a>01103         {
<a name="l01104"></a>01104             add(gnu, usage, argc, (<span class="keyword">const</span> <span class="keywordtype">char</span>**)argv, min_abbr_len,
<a name="l01105"></a>01105                 single_minus_longopt);
<a name="l01106"></a>01106         }
<a name="l01107"></a>01107 
<a name="l01109"></a><a class="code" href="../../d8/de3/structoption_1_1Stats.html#ab5cafb7127099ef60cfb4cea205ad617">01109</a>         <a class="code" href="../../d8/de3/structoption_1_1Stats.html" title="Determines the minimum lengths of the buffer and options arrays used for Parser.">Stats</a>(<span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv,
<a name="l01110"></a>01110               <span class="keywordtype">int</span> min_abbr_len = 0, <span class="comment">//</span>
<a name="l01111"></a>01111               <span class="keywordtype">bool</span> single_minus_longopt = <span class="keyword">false</span>)
<a name="l01112"></a>01112             : buffer_max(1), options_max(1) <span class="comment">// 1 more than necessary as sentinel</span>
<a name="l01113"></a>01113         {
<a name="l01114"></a>01114             add(<span class="keyword">false</span>, usage, argc, argv, min_abbr_len, single_minus_longopt);
<a name="l01115"></a>01115         }
<a name="l01116"></a>01116 
<a name="l01118"></a><a class="code" href="../../d8/de3/structoption_1_1Stats.html#a9b8b4f275efaac6a509df75179929c70">01118</a>         <a class="code" href="../../d8/de3/structoption_1_1Stats.html" title="Determines the minimum lengths of the buffer and options arrays used for Parser.">Stats</a>(<span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv,
<a name="l01119"></a>01119               <span class="keywordtype">int</span> min_abbr_len = 0, <span class="comment">//</span>
<a name="l01120"></a>01120               <span class="keywordtype">bool</span> single_minus_longopt = <span class="keyword">false</span>)
<a name="l01121"></a>01121             : buffer_max(1), options_max(1) <span class="comment">// 1 more than necessary as sentinel</span>
<a name="l01122"></a>01122         {
<a name="l01123"></a>01123             add(<span class="keyword">false</span>, usage, argc, (<span class="keyword">const</span> <span class="keywordtype">char</span>**)argv, min_abbr_len,
<a name="l01124"></a>01124                 single_minus_longopt);
<a name="l01125"></a>01125         }
<a name="l01126"></a>01126 
<a name="l01138"></a>01138         <span class="keywordtype">void</span> add(<span class="keywordtype">bool</span> gnu, <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> argc,
<a name="l01139"></a>01139                  <span class="keyword">const</span> <span class="keywordtype">char</span>** argv,
<a name="l01140"></a>01140                  <span class="keywordtype">int</span> min_abbr_len = 0, <span class="comment">//</span>
<a name="l01141"></a>01141                  <span class="keywordtype">bool</span> single_minus_longopt = <span class="keyword">false</span>);
<a name="l01142"></a>01142 
<a name="l01144"></a><a class="code" href="../../d8/de3/structoption_1_1Stats.html#a2aa7bc64a85dcd9c59576f6a11c2b747">01144</a>         <span class="keywordtype">void</span> add(<span class="keywordtype">bool</span> gnu, <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv,
<a name="l01145"></a>01145                  <span class="keywordtype">int</span> min_abbr_len = 0, <span class="comment">//</span>
<a name="l01146"></a>01146                  <span class="keywordtype">bool</span> single_minus_longopt = <span class="keyword">false</span>) {
<a name="l01147"></a>01147             add(gnu, usage, argc, (<span class="keyword">const</span> <span class="keywordtype">char</span>**)argv, min_abbr_len,
<a name="l01148"></a>01148                 single_minus_longopt);
<a name="l01149"></a>01149         }
<a name="l01150"></a>01150 
<a name="l01152"></a><a class="code" href="../../d8/de3/structoption_1_1Stats.html#a4fc47be5db7f52016e3142a9b9dd0d1e">01152</a>         <span class="keywordtype">void</span> add(<span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv,
<a name="l01153"></a>01153                  <span class="keywordtype">int</span> min_abbr_len = 0, <span class="comment">//</span>
<a name="l01154"></a>01154                  <span class="keywordtype">bool</span> single_minus_longopt = <span class="keyword">false</span>) {
<a name="l01155"></a>01155             add(<span class="keyword">false</span>, usage, argc, argv, min_abbr_len, single_minus_longopt);
<a name="l01156"></a>01156         }
<a name="l01157"></a>01157 
<a name="l01159"></a><a class="code" href="../../d8/de3/structoption_1_1Stats.html#ad659604438f79c79f5bc009f2a16ca92">01159</a>         <span class="keywordtype">void</span> add(<span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv,
<a name="l01160"></a>01160                  <span class="keywordtype">int</span> min_abbr_len = 0, <span class="comment">//</span>
<a name="l01161"></a>01161                  <span class="keywordtype">bool</span> single_minus_longopt = <span class="keyword">false</span>) {
<a name="l01162"></a>01162             add(<span class="keyword">false</span>, usage, argc, (<span class="keyword">const</span> <span class="keywordtype">char</span>**)argv, min_abbr_len,
<a name="l01163"></a>01163                 single_minus_longopt);
<a name="l01164"></a>01164         }
<a name="l01165"></a>01165 
<a name="l01166"></a>01166       <span class="keyword">private</span>:
<a name="l01167"></a><a class="code" href="../../d8/de3/structoption_1_1Stats.html#a45ce34facb5c01feff85721248dc9b6c">01167</a>         <span class="keyword">class </span><a class="code" href="../../de/df0/utilities_8h.html#ad8ce4efaa307683d3d763b37b4711c53">API</a> CountOptionsAction;
<a name="l01168"></a>01168     };
<a name="l01169"></a>01169 
<a name="l01190"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html">01190</a>     <span class="keyword">class </span><a class="code" href="../../de/df0/utilities_8h.html#ad8ce4efaa307683d3d763b37b4711c53">API</a> <a class="code" href="../../d6/d83/classoption_1_1Parser.html" title="Checks argument vectors for validity and parses them into data structures that are...">Parser</a> {
<a name="l01191"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#a4e691e4afd841d7e29f26e77468f3260">01191</a>         <span class="keywordtype">int</span> op_count;            
<a name="l01192"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#a3e17e9a2958006b81d99ed5981ed2b9e">01192</a>         <span class="keywordtype">int</span> nonop_count;         
<a name="l01193"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#ab6df1186f1e85a80366573b3e0c7bbf6">01193</a>         <span class="keyword">const</span> <span class="keywordtype">char</span>** nonop_args; 
<a name="l01194"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#ac982fccc777759d1e699302a072d728c">01194</a>         <span class="keywordtype">bool</span> err;                
<a name="l01195"></a>01195       <span class="keyword">public</span>:
<a name="l01199"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#a895e9a1db19f1a026ee6a7412de17d04">01199</a>         <a class="code" href="../../d6/d83/classoption_1_1Parser.html#a895e9a1db19f1a026ee6a7412de17d04" title="Creates a new Parser.">Parser</a>() : op_count(0), nonop_count(0), nonop_args(0), err(false) {}
<a name="l01200"></a>01200 
<a name="l01206"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#aa747e9792c9c08ede32b6c323438db71">01206</a>         <a class="code" href="../../d6/d83/classoption_1_1Parser.html" title="Checks argument vectors for validity and parses them into data structures that are...">Parser</a>(<span class="keywordtype">bool</span> gnu, <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv,
<a name="l01207"></a>01207                <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> options[], <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> buffer[], <span class="keywordtype">int</span> min_abbr_len = 0,
<a name="l01208"></a>01208                <span class="keywordtype">bool</span> single_minus_longopt = <span class="keyword">false</span>, <span class="keywordtype">int</span> bufmax = -1)
<a name="l01209"></a>01209             : op_count(0), nonop_count(0), nonop_args(0), err(false) {
<a name="l01210"></a>01210             parse(gnu, usage, argc, argv, options, buffer, min_abbr_len,
<a name="l01211"></a>01211                   single_minus_longopt, bufmax);
<a name="l01212"></a>01212         }
<a name="l01213"></a>01213 
<a name="l01215"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#a78b4c7d73fff17204dd908b1b167dec9">01215</a>         <a class="code" href="../../d6/d83/classoption_1_1Parser.html" title="Checks argument vectors for validity and parses them into data structures that are...">Parser</a>(<span class="keywordtype">bool</span> gnu, <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv,
<a name="l01216"></a>01216                <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> options[], <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> buffer[], <span class="keywordtype">int</span> min_abbr_len = 0,
<a name="l01217"></a>01217                <span class="keywordtype">bool</span> single_minus_longopt = <span class="keyword">false</span>, <span class="keywordtype">int</span> bufmax = -1)
<a name="l01218"></a>01218             : op_count(0), nonop_count(0), nonop_args(0), err(false) {
<a name="l01219"></a>01219             parse(gnu, usage, argc, (<span class="keyword">const</span> <span class="keywordtype">char</span>**)argv, options, buffer,
<a name="l01220"></a>01220                   min_abbr_len, single_minus_longopt, bufmax);
<a name="l01221"></a>01221         }
<a name="l01222"></a>01222 
<a name="l01224"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#ae4100da4b662937ead22484e6cfc7cec">01224</a>         <a class="code" href="../../d6/d83/classoption_1_1Parser.html" title="Checks argument vectors for validity and parses them into data structures that are...">Parser</a>(<span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv,
<a name="l01225"></a>01225                <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> options[], <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> buffer[], <span class="keywordtype">int</span> min_abbr_len = 0,
<a name="l01226"></a>01226                <span class="keywordtype">bool</span> single_minus_longopt = <span class="keyword">false</span>, <span class="keywordtype">int</span> bufmax = -1)
<a name="l01227"></a>01227             : op_count(0), nonop_count(0), nonop_args(0), err(false) {
<a name="l01228"></a>01228             parse(<span class="keyword">false</span>, usage, argc, argv, options, buffer, min_abbr_len,
<a name="l01229"></a>01229                   single_minus_longopt, bufmax);
<a name="l01230"></a>01230         }
<a name="l01231"></a>01231 
<a name="l01233"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#a23ee244634a38d05f6c4cb1e3692a8a9">01233</a>         <a class="code" href="../../d6/d83/classoption_1_1Parser.html" title="Checks argument vectors for validity and parses them into data structures that are...">Parser</a>(<span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv,
<a name="l01234"></a>01234                <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> options[], <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> buffer[], <span class="keywordtype">int</span> min_abbr_len = 0,
<a name="l01235"></a>01235                <span class="keywordtype">bool</span> single_minus_longopt = <span class="keyword">false</span>, <span class="keywordtype">int</span> bufmax = -1)
<a name="l01236"></a>01236             : op_count(0), nonop_count(0), nonop_args(0), err(false) {
<a name="l01237"></a>01237             parse(<span class="keyword">false</span>, usage, argc, (<span class="keyword">const</span> <span class="keywordtype">char</span>**)argv, options, buffer,
<a name="l01238"></a>01238                   min_abbr_len, single_minus_longopt, bufmax);
<a name="l01239"></a>01239         }
<a name="l01240"></a>01240 
<a name="l01336"></a>01336         <span class="keywordtype">void</span> parse(<span class="keywordtype">bool</span> gnu, <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> argc,
<a name="l01337"></a>01337                    <span class="keyword">const</span> <span class="keywordtype">char</span>** argv, <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> options[], <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> buffer[],
<a name="l01338"></a>01338                    <span class="keywordtype">int</span> min_abbr_len = 0, <span class="keywordtype">bool</span> single_minus_longopt = <span class="keyword">false</span>,
<a name="l01339"></a>01339                    <span class="keywordtype">int</span> bufmax = -1);
<a name="l01340"></a>01340 
<a name="l01342"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#ab26280e3b2ebc2f2fc4ed8b3b1e2a39c">01342</a>         <span class="keywordtype">void</span> parse(<span class="keywordtype">bool</span> gnu, <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv,
<a name="l01343"></a>01343                    <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> options[], <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> buffer[], <span class="keywordtype">int</span> min_abbr_len = 0,
<a name="l01344"></a>01344                    <span class="keywordtype">bool</span> single_minus_longopt = <span class="keyword">false</span>, <span class="keywordtype">int</span> bufmax = -1) {
<a name="l01345"></a>01345             parse(gnu, usage, argc, (<span class="keyword">const</span> <span class="keywordtype">char</span>**)argv, options, buffer,
<a name="l01346"></a>01346                   min_abbr_len, single_minus_longopt, bufmax);
<a name="l01347"></a>01347         }
<a name="l01348"></a>01348 
<a name="l01350"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#a41885a7308249c8532714e15b36106bd">01350</a>         <span class="keywordtype">void</span> parse(<span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span>** argv,
<a name="l01351"></a>01351                    <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> options[], <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> buffer[], <span class="keywordtype">int</span> min_abbr_len = 0,
<a name="l01352"></a>01352                    <span class="keywordtype">bool</span> single_minus_longopt = <span class="keyword">false</span>, <span class="keywordtype">int</span> bufmax = -1) {
<a name="l01353"></a>01353             parse(<span class="keyword">false</span>, usage, argc, argv, options, buffer, min_abbr_len,
<a name="l01354"></a>01354                   single_minus_longopt, bufmax);
<a name="l01355"></a>01355         }
<a name="l01356"></a>01356 
<a name="l01358"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#ad40585faa23a97a186cf9a45b8c2b42b">01358</a>         <span class="keywordtype">void</span> parse(<span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv,
<a name="l01359"></a>01359                    <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> options[], <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> buffer[], <span class="keywordtype">int</span> min_abbr_len = 0,
<a name="l01360"></a>01360                    <span class="keywordtype">bool</span> single_minus_longopt = <span class="keyword">false</span>, <span class="keywordtype">int</span> bufmax = -1) {
<a name="l01361"></a>01361             parse(<span class="keyword">false</span>, usage, argc, (<span class="keyword">const</span> <span class="keywordtype">char</span>**)argv, options, buffer,
<a name="l01362"></a>01362                   min_abbr_len, single_minus_longopt, bufmax);
<a name="l01363"></a>01363         }
<a name="l01364"></a>01364 
<a name="l01376"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#aee62badd2a19a5b88cbc4a9b11813b82">01376</a>         <span class="keywordtype">int</span> <a class="code" href="../../d6/d83/classoption_1_1Parser.html#aee62badd2a19a5b88cbc4a9b11813b82" title="Returns the number of valid Option objects in buffer[].">optionsCount</a>() { <span class="keywordflow">return</span> op_count; }
<a name="l01377"></a>01377 
<a name="l01400"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#aa64a6a7c196993a1b20d48e8ddd12a34">01400</a>         <span class="keywordtype">int</span> <a class="code" href="../../d6/d83/classoption_1_1Parser.html#aa64a6a7c196993a1b20d48e8ddd12a34" title="Returns the number of non-option arguments that remained at the end of the most recent...">nonOptionsCount</a>() { <span class="keywordflow">return</span> nonop_count; }
<a name="l01401"></a>01401 
<a name="l01417"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#a2c11b050f4248d71758dda52c5f9154d">01417</a>         <span class="keyword">const</span> <span class="keywordtype">char</span>** <a class="code" href="../../d6/d83/classoption_1_1Parser.html#a2c11b050f4248d71758dda52c5f9154d" title="Returns a pointer to an array of non-option arguments (only valid if nonOptionsCount()...">nonOptions</a>() { <span class="keywordflow">return</span> nonop_args; }
<a name="l01418"></a>01418 
<a name="l01423"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#aeeafbf2892a5aca90b89803b2b1cb031">01423</a>         <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="../../d6/d83/classoption_1_1Parser.html#aeeafbf2892a5aca90b89803b2b1cb031" title="Returns nonOptions()[i] (without checking if i is in range!).">nonOption</a>(<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> nonOptions()[i]; }
<a name="l01424"></a>01424 
<a name="l01445"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#a2caa149140067b4d13e4d7a104bb3090">01445</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d6/d83/classoption_1_1Parser.html#a2caa149140067b4d13e4d7a104bb3090" title="Returns true if an unrecoverable error occurred while parsing options.">error</a>() { <span class="keywordflow">return</span> err; }
<a name="l01446"></a>01446 
<a name="l01447"></a>01447       <span class="keyword">private</span>:
<a name="l01448"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#ac88f31ab163ecbec956dc83a479ee047">01448</a>         <span class="keyword">friend</span> <span class="keyword">struct </span><a class="code" href="../../de/df0/utilities_8h.html#ad8ce4efaa307683d3d763b37b4711c53">API</a> <a class="code" href="../../d8/de3/structoption_1_1Stats.html" title="Determines the minimum lengths of the buffer and options arrays used for Parser.">Stats</a>;
<a name="l01449"></a>01449 
<a name="l01450"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#a6412effab65b63a716bc42933b61d790">01450</a>         <span class="keyword">class </span><a class="code" href="../../de/df0/utilities_8h.html#ad8ce4efaa307683d3d763b37b4711c53">API</a> StoreOptionAction;
<a name="l01451"></a>01451 
<a name="l01452"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#a5424c5d504b236ab377d5ce267a20c5b">01452</a>         <span class="keyword">struct </span><a class="code" href="../../de/df0/utilities_8h.html#ad8ce4efaa307683d3d763b37b4711c53">API</a> <a class="code" href="../../d3/d10/classCountOptionsAction_01public_01Parser_1_1Action.html">Action</a>;
<a name="l01453"></a>01453 
<a name="l01459"></a>01459         <span class="keyword">static</span> <span class="keywordtype">bool</span> workhorse(<span class="keywordtype">bool</span> gnu, <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> numargs,
<a name="l01460"></a>01460                               <span class="keyword">const</span> <span class="keywordtype">char</span>** args, <a class="code" href="../../d3/d10/classCountOptionsAction_01public_01Parser_1_1Action.html">Action</a>&amp; action,
<a name="l01461"></a>01461                               <span class="keywordtype">bool</span> single_minus_longopt, <span class="keywordtype">bool</span> print_errors,
<a name="l01462"></a>01462                               <span class="keywordtype">int</span> min_abbr_len);
<a name="l01463"></a>01463 
<a name="l01478"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#ab1638764142e2789b552b8cc3196e365">01478</a>         <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="../../d6/d83/classoption_1_1Parser.html#ab1638764142e2789b552b8cc3196e365">streq</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* st1, <span class="keyword">const</span> <span class="keywordtype">char</span>* st2) {
<a name="l01479"></a>01479             <span class="keywordflow">while</span> (*st1 != 0)
<a name="l01480"></a>01480                 <span class="keywordflow">if</span> (*st1++ != *st2++)
<a name="l01481"></a>01481                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01482"></a>01482             <span class="keywordflow">return</span> (*st2 == 0 || *st2 == <span class="charliteral">&apos;=&apos;</span>);
<a name="l01483"></a>01483         }
<a name="l01484"></a>01484 
<a name="l01511"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#abcdbe5be641eb3586a0602a4189dc913">01511</a>         <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="../../d6/d83/classoption_1_1Parser.html#abcdbe5be641eb3586a0602a4189dc913">streqabbr</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* st1, <span class="keyword">const</span> <span class="keywordtype">char</span>* st2, <span class="keywordtype">long</span> <span class="keywordtype">long</span> <a class="code" href="../../df/d6d/namespacemymath.html#a4220093922a0ab5e3a6e265b0c94ec89">min</a>) {
<a name="l01512"></a>01512             <span class="keyword">const</span> <span class="keywordtype">char</span>* st1start = st1;
<a name="l01513"></a>01513             <span class="keywordflow">while</span> (*st1 != 0 &amp;&amp; (*st1 == *st2)) {
<a name="l01514"></a>01514                 ++st1;
<a name="l01515"></a>01515                 ++st2;
<a name="l01516"></a>01516             }
<a name="l01517"></a>01517 
<a name="l01518"></a>01518             <span class="keywordflow">return</span> (*st1 == 0 || (min &gt; 0 &amp;&amp; (st1 - st1start) &gt;= min)) &amp;&amp;
<a name="l01519"></a>01519                    (*st2 == 0 || *st2 == <span class="charliteral">&apos;=&apos;</span>);
<a name="l01520"></a>01520         }
<a name="l01521"></a>01521 
<a name="l01529"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#aadfd08a040c5eac5bc09356071a28e49">01529</a>         <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="../../d6/d83/classoption_1_1Parser.html#aadfd08a040c5eac5bc09356071a28e49">instr</a>(<span class="keywordtype">char</span> ch, <span class="keyword">const</span> <span class="keywordtype">char</span>* st) {
<a name="l01530"></a>01530             <span class="keywordflow">while</span> (*st != 0 &amp;&amp; *st != ch)
<a name="l01531"></a>01531                 ++st;
<a name="l01532"></a>01532             <span class="keywordflow">return</span> *st == ch;
<a name="l01533"></a>01533         }
<a name="l01534"></a>01534 
<a name="l01541"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#a50028a8c1f78607119e164ba8059018c">01541</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="../../d6/d83/classoption_1_1Parser.html#a50028a8c1f78607119e164ba8059018c">shift</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>** args, <span class="keywordtype">int</span> count) {
<a name="l01542"></a>01542             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &gt; -count; --i) {
<a name="l01543"></a>01543                 <span class="keyword">const</span> <span class="keywordtype">char</span>* temp = args[i];
<a name="l01544"></a>01544                 args[i] = args[i - 1];
<a name="l01545"></a>01545                 args[i - 1] = temp;
<a name="l01546"></a>01546             }
<a name="l01547"></a>01547         }
<a name="l01548"></a>01548     };
<a name="l01549"></a>01549 
<a name="l01556"></a>01556     <span class="keyword">struct </span><a class="code" href="../../de/df0/utilities_8h.html#ad8ce4efaa307683d3d763b37b4711c53">API</a> Parser::<a class="code" href="../../d3/d10/classCountOptionsAction_01public_01Parser_1_1Action.html">Action</a> {
<a name="l01568"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#a24c3d7b267a97d98bba7b3cd6d915470">01568</a>         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="../../d6/d83/classoption_1_1Parser.html#a24c3d7b267a97d98bba7b3cd6d915470" title="Called by Parser::workhorse() for each Option that has been successfully parsed (including...">perform</a>(<a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>&amp;) { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l01569"></a>01569 
<a name="l01579"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#a9b5d752a49135a7f85d36e06877c7bfc">01579</a>         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="../../d6/d83/classoption_1_1Parser.html#a9b5d752a49135a7f85d36e06877c7bfc" title="Called by Parser::workhorse() after finishing the parse.">finished</a>(<span class="keywordtype">int</span> numargs, <span class="keyword">const</span> <span class="keywordtype">char</span>** args) {
<a name="l01580"></a>01580             (void)numargs;
<a name="l01581"></a>01581             (void)args;
<a name="l01582"></a>01582             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01583"></a>01583         }
<a name="l01584"></a>01584     };
<a name="l01585"></a>01585 
<a name="l01592"></a>01592     <span class="keyword">class </span><a class="code" href="../../de/df0/utilities_8h.html#ad8ce4efaa307683d3d763b37b4711c53">API</a> Stats::CountOptionsAction : <span class="keyword">public</span> Parser::<a class="code" href="../../d3/d10/classCountOptionsAction_01public_01Parser_1_1Action.html">Action</a> {
<a name="l01593"></a><a class="code" href="../../d8/de3/structoption_1_1Stats.html#ac9f390594a5a52f52c6b998e84d33be5">01593</a>         <span class="keywordtype">unsigned</span>* buffer_max;
<a name="l01594"></a>01594 
<a name="l01595"></a>01595       <span class="keyword">public</span>:
<a name="l01601"></a><a class="code" href="../../d8/de3/structoption_1_1Stats.html#a28ccea28ff81bf255bb43a2359a14d3e">01601</a>         <a class="code" href="../../d8/de3/structoption_1_1Stats.html#a28ccea28ff81bf255bb43a2359a14d3e">CountOptionsAction</a>(<span class="keywordtype">unsigned</span>* buffer_max_) : buffer_max(buffer_max_) {}
<a name="l01602"></a>01602 
<a name="l01603"></a><a class="code" href="../../d8/de3/structoption_1_1Stats.html#a1a7ef15dbe2f3c5df1b607869c37d2ab">01603</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d8/de3/structoption_1_1Stats.html#a1a7ef15dbe2f3c5df1b607869c37d2ab">perform</a>(<a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>&amp;) {
<a name="l01604"></a>01604             <span class="keywordflow">if</span> (*buffer_max == 0x7fffffff)
<a name="l01605"></a>01605                 <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// overflow protection: don&apos;t accept number of</span>
<a name="l01606"></a>01606                               <span class="comment">// options that doesn&apos;t fit signed int</span>
<a name="l01607"></a>01607             ++*buffer_max;
<a name="l01608"></a>01608             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01609"></a>01609         }
<a name="l01610"></a>01610     };
<a name="l01611"></a>01611 
<a name="l01618"></a>01618     <span class="keyword">class </span><a class="code" href="../../de/df0/utilities_8h.html#ad8ce4efaa307683d3d763b37b4711c53">API</a> Parser::StoreOptionAction : <span class="keyword">public</span> Parser::<a class="code" href="../../d3/d10/classCountOptionsAction_01public_01Parser_1_1Action.html">Action</a> {
<a name="l01619"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#a5799d3b9046c5326c757bcdacbb6c2ce">01619</a>         <a class="code" href="../../d6/d83/classoption_1_1Parser.html" title="Checks argument vectors for validity and parses them into data structures that are...">Parser</a>&amp; parser;
<a name="l01620"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#a3020e9c73856f71bbcd0c24bda2be88e">01620</a>         <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* options;
<a name="l01621"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#aeca132c3b03ffb69cd276eb87960295f">01621</a>         <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>* buffer;
<a name="l01622"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#a64411429028fb6ab915f189eb9733a71">01622</a>         <span class="keywordtype">int</span> bufmax; 
<a name="l01623"></a>01623 
<a name="l01624"></a>01624       <span class="keyword">public</span>:
<a name="l01635"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#ae26ec5a54decdbc4102a5badc1bc8b55">01635</a>         StoreOptionAction(<a class="code" href="../../d6/d83/classoption_1_1Parser.html" title="Checks argument vectors for validity and parses them into data structures that are...">Parser</a>&amp; parser_, <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> options_[], <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> buffer_[],
<a name="l01636"></a>01636                           <span class="keywordtype">int</span> bufmax_)
<a name="l01637"></a>01637             : parser(parser_), options(options_), buffer(buffer_),
<a name="l01638"></a>01638               bufmax(bufmax_) {
<a name="l01639"></a>01639             <span class="comment">// find first empty slot in buffer (if any)</span>
<a name="l01640"></a>01640             <span class="keywordtype">int</span> bufidx = 0;
<a name="l01641"></a>01641             <span class="keywordflow">while</span> ((bufmax &lt; 0 || bufidx &lt; bufmax) &amp;&amp; buffer[bufidx])
<a name="l01642"></a>01642                 ++bufidx;
<a name="l01643"></a>01643 
<a name="l01644"></a>01644             <span class="comment">// set parser&apos;s optionCount</span>
<a name="l01645"></a>01645             parser.op_count = bufidx;
<a name="l01646"></a>01646         }
<a name="l01647"></a>01647 
<a name="l01648"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#aa939da4bb4f7c1fefb5daf6479da1fbb">01648</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d6/d83/classoption_1_1Parser.html#aa939da4bb4f7c1fefb5daf6479da1fbb">perform</a>(<a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a>&amp; option) {
<a name="l01649"></a>01649             <span class="keywordflow">if</span> (bufmax &lt; 0 || parser.op_count &lt; bufmax) {
<a name="l01650"></a>01650                 <span class="keywordflow">if</span> (parser.op_count == 0x7fffffff)
<a name="l01651"></a>01651                     <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// overflow protection: don&apos;t accept number of</span>
<a name="l01652"></a>01652                                   <span class="comment">// options that doesn&apos;t fit signed int</span>
<a name="l01653"></a>01653 
<a name="l01654"></a>01654                 buffer[parser.op_count] = option;
<a name="l01655"></a>01655                 <span class="keywordtype">int</span> idx = buffer[parser.op_count].<a class="code" href="../../d3/df3/classoption_1_1Option.html#af8d664a7b5de1425008b1812a90a0c23" title="Pointer to this Option&amp;#39;s Descriptor.">desc</a>-&gt;<a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html#a1fee8ac44f529c99ac2b1149b4c391b1" title="Index of this option&amp;#39;s linked list in the array filled in by the parser.">index</a>;
<a name="l01656"></a>01656                 <span class="keywordflow">if</span> (options[idx])
<a name="l01657"></a>01657                     options[idx].append(buffer[parser.op_count]);
<a name="l01658"></a>01658                 <span class="keywordflow">else</span>
<a name="l01659"></a>01659                     options[idx] = buffer[parser.op_count];
<a name="l01660"></a>01660                 ++parser.op_count;
<a name="l01661"></a>01661             }
<a name="l01662"></a>01662             <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// NOTE: an option that is discarded because of a full</span>
<a name="l01663"></a>01663                          <span class="comment">// buffer is not fatal</span>
<a name="l01664"></a>01664         }
<a name="l01665"></a>01665 
<a name="l01666"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#af2e20ef22d804ba63bfb033572357424">01666</a>         <span class="keywordtype">bool</span> <a class="code" href="../../d6/d83/classoption_1_1Parser.html#af2e20ef22d804ba63bfb033572357424">finished</a>(<span class="keywordtype">int</span> numargs, <span class="keyword">const</span> <span class="keywordtype">char</span>** args) {
<a name="l01667"></a>01667             <span class="comment">// only overwrite non-option argument list if there&apos;s at least 1</span>
<a name="l01668"></a>01668             <span class="comment">// new non-option argument. Otherwise we keep the old list. This</span>
<a name="l01669"></a>01669             <span class="comment">// makes it easy to use default non-option arguments.</span>
<a name="l01670"></a>01670             <span class="keywordflow">if</span> (numargs &gt; 0) {
<a name="l01671"></a>01671                 parser.nonop_count = numargs;
<a name="l01672"></a>01672                 parser.nonop_args = args;
<a name="l01673"></a>01673             }
<a name="l01674"></a>01674 
<a name="l01675"></a>01675             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01676"></a>01676         }
<a name="l01677"></a>01677     };
<a name="l01678"></a>01678 
<a name="l01679"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#a6e0b5778d1cfbd6cd51240e74d01e138">01679</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="../../d6/d83/classoption_1_1Parser.html#a6e0b5778d1cfbd6cd51240e74d01e138" title="Parses the given argument vector.">Parser::parse</a>(<span class="keywordtype">bool</span> gnu, <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> argc,
<a name="l01680"></a>01680                               <span class="keyword">const</span> <span class="keywordtype">char</span>** argv, <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> options[],
<a name="l01681"></a>01681                               <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> buffer[], <span class="keywordtype">int</span> min_abbr_len,
<a name="l01682"></a>01682                               <span class="keywordtype">bool</span> single_minus_longopt, <span class="keywordtype">int</span> bufmax) {
<a name="l01683"></a>01683         <a class="code" href="../../d6/d83/classoption_1_1Parser.html#a6412effab65b63a716bc42933b61d790">StoreOptionAction</a> action(*<span class="keyword">this</span>, options, buffer, bufmax);
<a name="l01684"></a>01684         <a class="code" href="../../d6/d83/classoption_1_1Parser.html#ac982fccc777759d1e699302a072d728c">err</a> = !<a class="code" href="../../d6/d83/classoption_1_1Parser.html#ab8c03a700a6f350bba434b3482a6563b">workhorse</a>(gnu, usage, argc, argv, action, single_minus_longopt,
<a name="l01685"></a>01685                          <span class="keyword">true</span>, min_abbr_len);
<a name="l01686"></a>01686     }
<a name="l01687"></a>01687 
<a name="l01688"></a><a class="code" href="../../d8/de3/structoption_1_1Stats.html#aa77e2a8b1704527d2d087820f4456143">01688</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="../../d8/de3/structoption_1_1Stats.html#aa77e2a8b1704527d2d087820f4456143" title="Updates this Stats object for the given usage and argument vector. You may pass 0...">Stats::add</a>(<span class="keywordtype">bool</span> gnu, <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> argc,
<a name="l01689"></a>01689                            <span class="keyword">const</span> <span class="keywordtype">char</span>** argv, <span class="keywordtype">int</span> min_abbr_len,
<a name="l01690"></a>01690                            <span class="keywordtype">bool</span> single_minus_longopt) {
<a name="l01691"></a>01691         <span class="comment">// determine size of options array. This is the greatest index used in</span>
<a name="l01692"></a>01692         <span class="comment">// the usage + 1</span>
<a name="l01693"></a>01693         <span class="keywordtype">int</span> i = 0;
<a name="l01694"></a>01694         <span class="keywordflow">while</span> (usage[i].shortopt != 0) {
<a name="l01695"></a>01695             <span class="keywordflow">if</span> (usage[i].index + 1 &gt;= <a class="code" href="../../d8/de3/structoption_1_1Stats.html#a8121787feb1c7db84fca3ccb012b0473" title="Number of elements needed for an options[] array to be used for parsing the same...">options_max</a>)
<a name="l01696"></a>01696                 <a class="code" href="../../d8/de3/structoption_1_1Stats.html#a8121787feb1c7db84fca3ccb012b0473" title="Number of elements needed for an options[] array to be used for parsing the same...">options_max</a> = (usage[i].<a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html#a1fee8ac44f529c99ac2b1149b4c391b1" title="Index of this option&amp;#39;s linked list in the array filled in by the parser.">index</a> + 1) +
<a name="l01697"></a>01697                               1; <span class="comment">// 1 more than necessary as sentinel</span>
<a name="l01698"></a>01698 
<a name="l01699"></a>01699             ++i;
<a name="l01700"></a>01700         }
<a name="l01701"></a>01701 
<a name="l01702"></a>01702         <a class="code" href="../../d8/de3/structoption_1_1Stats.html#a45ce34facb5c01feff85721248dc9b6c">CountOptionsAction</a> action(&amp;<a class="code" href="../../d8/de3/structoption_1_1Stats.html#a2c9a7b4174f91ba8bcadaa9ad6f0db06" title="Number of elements needed for a buffer[] array to be used for parsing the same argument...">buffer_max</a>);
<a name="l01703"></a>01703         <a class="code" href="../../d6/d83/classoption_1_1Parser.html#ab8c03a700a6f350bba434b3482a6563b">Parser::workhorse</a>(gnu, usage, argc, argv, action, single_minus_longopt,
<a name="l01704"></a>01704                           <span class="keyword">false</span>, min_abbr_len);
<a name="l01705"></a>01705     }
<a name="l01706"></a>01706 
<a name="l01707"></a><a class="code" href="../../d6/d83/classoption_1_1Parser.html#ab8c03a700a6f350bba434b3482a6563b">01707</a>     <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="../../d6/d83/classoption_1_1Parser.html#ab8c03a700a6f350bba434b3482a6563b">Parser::workhorse</a>(<span class="keywordtype">bool</span> gnu, <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[],
<a name="l01708"></a>01708                                   <span class="keywordtype">int</span> numargs, <span class="keyword">const</span> <span class="keywordtype">char</span>** args,
<a name="l01709"></a>01709                                   <a class="code" href="../../d3/d10/classCountOptionsAction_01public_01Parser_1_1Action.html">Action</a>&amp; action, <span class="keywordtype">bool</span> single_minus_longopt,
<a name="l01710"></a>01710                                   <span class="keywordtype">bool</span> print_errors, <span class="keywordtype">int</span> min_abbr_len) {
<a name="l01711"></a>01711         <span class="comment">// protect against NULL pointer</span>
<a name="l01712"></a>01712         <span class="keywordflow">if</span> (args == 0)
<a name="l01713"></a>01713             numargs = 0;
<a name="l01714"></a>01714 
<a name="l01715"></a>01715         <span class="keywordtype">int</span> nonops = 0;
<a name="l01716"></a>01716 
<a name="l01717"></a>01717         <span class="keywordflow">while</span> (numargs != 0 &amp;&amp; *args != 0) {
<a name="l01718"></a>01718             <span class="keyword">const</span> <span class="keywordtype">char</span>* param = *args; <span class="comment">// param can be --long-option, -srto or</span>
<a name="l01719"></a>01719                                        <span class="comment">// non-option argument</span>
<a name="l01720"></a>01720 
<a name="l01721"></a>01721             <span class="comment">// in POSIX mode the first non-option argument terminates the option</span>
<a name="l01722"></a>01722             <span class="comment">// list</span>
<a name="l01723"></a>01723             <span class="comment">// a lone minus character is a non-option argument</span>
<a name="l01724"></a>01724             <span class="keywordflow">if</span> (param[0] != <span class="charliteral">&apos;-&apos;</span> || param[1] == 0) {
<a name="l01725"></a>01725                 <span class="keywordflow">if</span> (gnu) {
<a name="l01726"></a>01726                     ++nonops;
<a name="l01727"></a>01727                     ++args;
<a name="l01728"></a>01728                     <span class="keywordflow">if</span> (numargs &gt; 0)
<a name="l01729"></a>01729                         --numargs;
<a name="l01730"></a>01730                     <span class="keywordflow">continue</span>;
<a name="l01731"></a>01731                 } <span class="keywordflow">else</span>
<a name="l01732"></a>01732                     <span class="keywordflow">break</span>;
<a name="l01733"></a>01733             }
<a name="l01734"></a>01734 
<a name="l01735"></a>01735             <span class="comment">// -- terminates the option list. The -- itself is skipped.</span>
<a name="l01736"></a>01736             <span class="keywordflow">if</span> (param[1] == <span class="charliteral">&apos;-&apos;</span> &amp;&amp; param[2] == 0) {
<a name="l01737"></a>01737                 <a class="code" href="../../d6/d83/classoption_1_1Parser.html#a50028a8c1f78607119e164ba8059018c">shift</a>(args, nonops);
<a name="l01738"></a>01738                 ++args;
<a name="l01739"></a>01739                 <span class="keywordflow">if</span> (numargs &gt; 0)
<a name="l01740"></a>01740                     --numargs;
<a name="l01741"></a>01741                 <span class="keywordflow">break</span>;
<a name="l01742"></a>01742             }
<a name="l01743"></a>01743 
<a name="l01744"></a>01744             <span class="keywordtype">bool</span> handle_short_options;
<a name="l01745"></a>01745             <span class="keyword">const</span> <span class="keywordtype">char</span>* longopt_name;
<a name="l01746"></a>01746             <span class="keywordflow">if</span> (param[1] == <span class="charliteral">&apos;-&apos;</span>) { <span class="comment">// if --long-option</span>
<a name="l01747"></a>01747                 handle_short_options = <span class="keyword">false</span>;
<a name="l01748"></a>01748                 longopt_name = param + 2;
<a name="l01749"></a>01749             } <span class="keywordflow">else</span> {
<a name="l01750"></a>01750                 handle_short_options = <span class="keyword">true</span>;
<a name="l01751"></a>01751                 longopt_name = param + 1; <span class="comment">// for testing a potential</span>
<a name="l01752"></a>01752                                           <span class="comment">// -long-option</span>
<a name="l01753"></a>01753             }
<a name="l01754"></a>01754 
<a name="l01755"></a>01755             <span class="keywordtype">bool</span> try_single_minus_longopt = single_minus_longopt;
<a name="l01756"></a>01756             <span class="keywordtype">bool</span> have_more_args =
<a name="l01757"></a>01757                 (numargs &gt; 1 || numargs &lt; 0); <span class="comment">// is referencing argv[1] valid?</span>
<a name="l01758"></a>01758 
<a name="l01759"></a>01759             <span class="keywordflow">do</span> { <span class="comment">// loop over short options in group, for long options the body</span>
<a name="l01760"></a>01760                  <span class="comment">// is executed only once</span>
<a name="l01761"></a>01761                 <span class="keywordtype">int</span> idx;
<a name="l01762"></a>01762 
<a name="l01763"></a>01763                 <span class="keyword">const</span> <span class="keywordtype">char</span>* optarg;
<a name="l01764"></a>01764 
<a name="l01765"></a>01765                 <span class="comment">/******************** long option **********************/</span>
<a name="l01766"></a>01766                 <span class="keywordflow">if</span> (handle_short_options == <span class="keyword">false</span> || try_single_minus_longopt) {
<a name="l01767"></a>01767                     idx = 0;
<a name="l01768"></a>01768                     <span class="keywordflow">while</span> (usage[idx].longopt != 0 &amp;&amp;
<a name="l01769"></a>01769                            !<a class="code" href="../../d6/d83/classoption_1_1Parser.html#ab1638764142e2789b552b8cc3196e365">streq</a>(usage[idx].longopt, longopt_name))
<a name="l01770"></a>01770                         ++idx;
<a name="l01771"></a>01771 
<a name="l01772"></a>01772                     <span class="keywordflow">if</span> (usage[idx].longopt == 0 &amp;&amp;
<a name="l01773"></a>01773                         min_abbr_len &gt; 0) { <span class="comment">// if we should try to match</span>
<a name="l01774"></a>01774                                             <span class="comment">// abbreviated long options</span>
<a name="l01775"></a>01775                         <span class="keywordtype">int</span> i1 = 0;
<a name="l01776"></a>01776                         <span class="keywordflow">while</span> (usage[i1].longopt != 0 &amp;&amp;
<a name="l01777"></a>01777                                !<a class="code" href="../../d6/d83/classoption_1_1Parser.html#abcdbe5be641eb3586a0602a4189dc913">streqabbr</a>(usage[i1].longopt, longopt_name,
<a name="l01778"></a>01778                                           min_abbr_len))
<a name="l01779"></a>01779                             ++i1;
<a name="l01780"></a>01780                         <span class="keywordflow">if</span> (usage[i1].longopt != 0) {
<a name="l01781"></a>01781                             <span class="comment">// now test if the match is unambiguous by checking</span>
<a name="l01782"></a>01782                             <span class="comment">// for another match</span>
<a name="l01783"></a>01783                             <span class="keywordtype">int</span> i2 = i1 + 1;
<a name="l01784"></a>01784                             <span class="keywordflow">while</span> (usage[i2].longopt != 0 &amp;&amp;
<a name="l01785"></a>01785                                    !<a class="code" href="../../d6/d83/classoption_1_1Parser.html#abcdbe5be641eb3586a0602a4189dc913">streqabbr</a>(usage[i2].longopt, longopt_name,
<a name="l01786"></a>01786                                               min_abbr_len))
<a name="l01787"></a>01787                                 ++i2;
<a name="l01788"></a>01788 
<a name="l01789"></a>01789                             <span class="keywordflow">if</span> (usage[i2].longopt == 0) <span class="comment">// if there was no</span>
<a name="l01790"></a>01790                                                         <span class="comment">// second match it&apos;s</span>
<a name="l01791"></a>01791                                                         <span class="comment">// unambiguous, so</span>
<a name="l01792"></a>01792                                                         <span class="comment">// accept i1 as idx</span>
<a name="l01793"></a>01793                                 idx = i1;
<a name="l01794"></a>01794                         }
<a name="l01795"></a>01795                     }
<a name="l01796"></a>01796 
<a name="l01797"></a>01797                     <span class="comment">// if we found something, disable handle_short_options (only</span>
<a name="l01798"></a>01798                     <span class="comment">// relevant if single_minus_longopt)</span>
<a name="l01799"></a>01799                     <span class="keywordflow">if</span> (usage[idx].longopt != 0)
<a name="l01800"></a>01800                         handle_short_options = <span class="keyword">false</span>;
<a name="l01801"></a>01801 
<a name="l01802"></a>01802                     try_single_minus_longopt = <span class="keyword">false</span>; <span class="comment">// prevent looking for</span>
<a name="l01803"></a>01803                                                       <span class="comment">// longopt in the middle</span>
<a name="l01804"></a>01804                                                       <span class="comment">// of shortopt group</span>
<a name="l01805"></a>01805 
<a name="l01806"></a>01806                     optarg = longopt_name;
<a name="l01807"></a>01807                     <span class="keywordflow">while</span> (*optarg != 0 &amp;&amp; *optarg != <span class="charliteral">&apos;=&apos;</span>)
<a name="l01808"></a>01808                         ++optarg;
<a name="l01809"></a>01809                     <span class="keywordflow">if</span> (*optarg == <span class="charliteral">&apos;=&apos;</span>) <span class="comment">// attached argument</span>
<a name="l01810"></a>01810                         ++optarg;
<a name="l01811"></a>01811                     <span class="keywordflow">else</span>
<a name="l01812"></a>01812                         <span class="comment">// possibly detached argument</span>
<a name="l01813"></a>01813                         optarg = (have_more_args ? args[1] : 0);
<a name="l01814"></a>01814                 }
<a name="l01815"></a>01815 
<a name="l01816"></a>01816                 <span class="comment">/************************ short option</span>
<a name="l01817"></a>01817 <span class="comment">                * ***********************************/</span>
<a name="l01818"></a>01818                 <span class="keywordflow">if</span> (handle_short_options) {
<a name="l01819"></a>01819                     <span class="keywordflow">if</span> (*++param == 0) <span class="comment">// point at the 1st/next option character</span>
<a name="l01820"></a>01820                         <span class="keywordflow">break</span>;         <span class="comment">// end of short option group</span>
<a name="l01821"></a>01821 
<a name="l01822"></a>01822                     idx = 0;
<a name="l01823"></a>01823                     <span class="keywordflow">while</span> (usage[idx].shortopt != 0 &amp;&amp;
<a name="l01824"></a>01824                            !<a class="code" href="../../d6/d83/classoption_1_1Parser.html#aadfd08a040c5eac5bc09356071a28e49">instr</a>(*param, usage[idx].shortopt))
<a name="l01825"></a>01825                         ++idx;
<a name="l01826"></a>01826 
<a name="l01827"></a>01827                     <span class="keywordflow">if</span> (param[1] == 0) <span class="comment">// if the potential argument is separate</span>
<a name="l01828"></a>01828                         optarg = (have_more_args ? args[1] : 0);
<a name="l01829"></a>01829                     <span class="keywordflow">else</span>
<a name="l01830"></a>01830                         <span class="comment">// if the potential argument is attached</span>
<a name="l01831"></a>01831                         optarg = param + 1;
<a name="l01832"></a>01832                 }
<a name="l01833"></a>01833 
<a name="l01834"></a>01834                 <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a>* descriptor = &amp;usage[idx];
<a name="l01835"></a>01835 
<a name="l01836"></a>01836                 <span class="keywordflow">if</span> (descriptor-&gt;<a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html#a0dba4ccca59c19d6ed4081391fca5adb" title="Each char in this string will be accepted as a short option character.">shortopt</a> ==
<a name="l01837"></a>01837                     0) { <span class="comment">/**************  unknown option ********************/</span>
<a name="l01838"></a>01838                     <span class="comment">// look for dummy entry (shortopt == &quot;&quot; and longopt == &quot;&quot;)</span>
<a name="l01839"></a>01839                     <span class="comment">// to use as Descriptor for unknown options</span>
<a name="l01840"></a>01840                     idx = 0;
<a name="l01841"></a>01841                     <span class="keywordflow">while</span> (usage[idx].shortopt != 0 &amp;&amp;
<a name="l01842"></a>01842                            (usage[idx].shortopt[0] != 0 ||
<a name="l01843"></a>01843                             usage[idx].longopt[0] != 0))
<a name="l01844"></a>01844                         ++idx;
<a name="l01845"></a>01845                     descriptor = (usage[idx].<a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html#a0dba4ccca59c19d6ed4081391fca5adb" title="Each char in this string will be accepted as a short option character.">shortopt</a> == 0 ? 0 : &amp;usage[idx]);
<a name="l01846"></a>01846                 }
<a name="l01847"></a>01847 
<a name="l01848"></a>01848                 <span class="keywordflow">if</span> (descriptor != 0) {
<a name="l01849"></a>01849                     <a class="code" href="../../d3/df3/classoption_1_1Option.html" title="A parsed option from the command line together with its argument if it has one.">Option</a> option(descriptor, param, optarg);
<a name="l01850"></a>01850                     <span class="keywordflow">switch</span> (descriptor-&gt;<a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html#aa5d675dba0214a4abd73007ff163cc67" title="For each option that matches shortopt or longopt this function will be called to...">check_arg</a>(option, print_errors)) {
<a name="l01851"></a>01851                     <span class="keywordflow">case</span> <a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a9528e32563b795bd2930b12d0a5e382d" title="The argument is not acceptable and that&amp;#39;s fatal.">ARG_ILLEGAL</a>:
<a name="l01852"></a>01852                         <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// fatal</span>
<a name="l01853"></a>01853                     <span class="keywordflow">case</span> <a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a445e08cb1747e5a22929e7ef2da43b55" title="The argument is acceptable for the option.">ARG_OK</a>:
<a name="l01854"></a>01854                         <span class="comment">// skip one element of the argument vector, if it&apos;s a</span>
<a name="l01855"></a>01855                         <span class="comment">// separated argument</span>
<a name="l01856"></a>01856                         <span class="keywordflow">if</span> (optarg != 0 &amp;&amp; have_more_args &amp;&amp;
<a name="l01857"></a>01857                             optarg == args[1]) {
<a name="l01858"></a>01858                             <a class="code" href="../../d6/d83/classoption_1_1Parser.html#a50028a8c1f78607119e164ba8059018c">shift</a>(args, nonops);
<a name="l01859"></a>01859                             <span class="keywordflow">if</span> (numargs &gt; 0)
<a name="l01860"></a>01860                                 --numargs;
<a name="l01861"></a>01861                             ++args;
<a name="l01862"></a>01862                         }
<a name="l01863"></a>01863 
<a name="l01864"></a>01864                         <span class="comment">// No further short options are possible after an</span>
<a name="l01865"></a>01865                         <span class="comment">// argument</span>
<a name="l01866"></a>01866                         handle_short_options = <span class="keyword">false</span>;
<a name="l01867"></a>01867 
<a name="l01868"></a>01868                         <span class="keywordflow">break</span>;
<a name="l01869"></a>01869                     <span class="keywordflow">case</span> <a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a83e0837c79c957525918111d33cab3a9" title="The argument is not acceptable but that&amp;#39;s non-fatal because the option&amp;#39;s...">ARG_IGNORE</a>:
<a name="l01870"></a>01870                     <span class="keywordflow">case</span> <a class="code" href="../../df/de0/namespaceoption.html#aee8c76a07877335762631491e7a5a1a9a353903b042e8eb0aa2f60c0043a58a7e" title="The option does not take an argument.">ARG_NONE</a>:
<a name="l01871"></a>01871                         option.<a class="code" href="../../d3/df3/classoption_1_1Option.html#a402be734987458364b0f473acae36238" title="Pointer to this Option&amp;#39;s argument (if any).">arg</a> = 0;
<a name="l01872"></a>01872                         <span class="keywordflow">break</span>;
<a name="l01873"></a>01873                     }
<a name="l01874"></a>01874 
<a name="l01875"></a>01875                     <span class="keywordflow">if</span> (!action.perform(option))
<a name="l01876"></a>01876                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01877"></a>01877                 }
<a name="l01878"></a>01878 
<a name="l01879"></a>01879             } <span class="keywordflow">while</span> (handle_short_options);
<a name="l01880"></a>01880 
<a name="l01881"></a>01881             <a class="code" href="../../d6/d83/classoption_1_1Parser.html#a50028a8c1f78607119e164ba8059018c">shift</a>(args, nonops);
<a name="l01882"></a>01882             ++args;
<a name="l01883"></a>01883             <span class="keywordflow">if</span> (numargs &gt; 0)
<a name="l01884"></a>01884                 --numargs;
<a name="l01885"></a>01885 
<a name="l01886"></a>01886         } <span class="comment">// while</span>
<a name="l01887"></a>01887 
<a name="l01888"></a>01888         <span class="keywordflow">if</span> (numargs &gt; 0 &amp;&amp; *args == 0) <span class="comment">// It&apos;s a bug in the caller if numargs is</span>
<a name="l01889"></a>01889                                        <span class="comment">// greater than the actual number</span>
<a name="l01890"></a>01890             numargs = 0; <span class="comment">// of arguments, but as a service to the user we fix</span>
<a name="l01891"></a>01891                          <span class="comment">// this if we spot it.</span>
<a name="l01892"></a>01892 
<a name="l01893"></a>01893         <span class="keywordflow">if</span> (numargs &lt; 0) { <span class="comment">// if we don&apos;t know the number of remaining</span>
<a name="l01894"></a>01894                            <span class="comment">// non-option arguments</span>
<a name="l01895"></a>01895                            <span class="comment">// we need to count them</span>
<a name="l01896"></a>01896             numargs = 0;
<a name="l01897"></a>01897             <span class="keywordflow">while</span> (args[numargs] != 0)
<a name="l01898"></a>01898                 ++numargs;
<a name="l01899"></a>01899         }
<a name="l01900"></a>01900 
<a name="l01901"></a>01901         <span class="keywordflow">return</span> action.finished(numargs + nonops, args - nonops);
<a name="l01902"></a>01902     }
<a name="l01903"></a>01903 
<a name="l01908"></a><a class="code" href="../../da/dfb/structoption_1_1PrintUsageImplementation.html">01908</a>     <span class="keyword">struct </span><a class="code" href="../../de/df0/utilities_8h.html#ad8ce4efaa307683d3d763b37b4711c53">API</a> <a class="code" href="../../da/dfb/structoption_1_1PrintUsageImplementation.html">PrintUsageImplementation</a> {
<a name="l01914"></a><a class="code" href="../../dd/d0b/structoption_1_1PrintUsageImplementation_1_1IStringWriter.html">01914</a>         <span class="keyword">struct </span><a class="code" href="../../de/df0/utilities_8h.html#ad8ce4efaa307683d3d763b37b4711c53">API</a> <a class="code" href="../../dd/d0b/structoption_1_1PrintUsageImplementation_1_1IStringWriter.html">IStringWriter</a> {
<a name="l01919"></a><a class="code" href="../../dd/d0b/structoption_1_1PrintUsageImplementation_1_1IStringWriter.html#a497172d92e09072a16996c127dd3def8">01919</a>             <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="../../dd/d0b/structoption_1_1PrintUsageImplementation_1_1IStringWriter.html#a497172d92e09072a16996c127dd3def8" title="Writes the given number of chars beginning at the given pointer somewhere.">operator()</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keywordtype">int</span>) {}
<a name="l01920"></a>01920         };
<a name="l01921"></a>01921 
<a name="l01928"></a>01928         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Function&gt;
<a name="l01929"></a><a class="code" href="../../df/dae/structoption_1_1PrintUsageImplementation_1_1FunctionWriter.html">01929</a>         <span class="keyword">struct </span><a class="code" href="../../df/dae/structoption_1_1PrintUsageImplementation_1_1FunctionWriter.html">FunctionWriter</a> : <span class="keyword">public</span> <a class="code" href="../../dd/d0b/structoption_1_1PrintUsageImplementation_1_1IStringWriter.html">IStringWriter</a> {
<a name="l01930"></a><a class="code" href="../../df/dae/structoption_1_1PrintUsageImplementation_1_1FunctionWriter.html#a3442e05eb04d2b1ee321193f5b10557b">01930</a>             Function* write;
<a name="l01931"></a>01931 
<a name="l01932"></a><a class="code" href="../../df/dae/structoption_1_1PrintUsageImplementation_1_1FunctionWriter.html#aa8e8f237845e210e36ca431d7e503a70">01932</a>             <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="../../df/dae/structoption_1_1PrintUsageImplementation_1_1FunctionWriter.html#aa8e8f237845e210e36ca431d7e503a70" title="Writes the given number of chars beginning at the given pointer somewhere.">operator()</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* str, <span class="keywordtype">int</span> size) {
<a name="l01933"></a>01933                 (*write)(str, size);
<a name="l01934"></a>01934             }
<a name="l01935"></a>01935 
<a name="l01936"></a><a class="code" href="../../df/dae/structoption_1_1PrintUsageImplementation_1_1FunctionWriter.html#adc6c3f7ba11b3cad65c018955bab47e5">01936</a>             <a class="code" href="../../df/dae/structoption_1_1PrintUsageImplementation_1_1FunctionWriter.html#adc6c3f7ba11b3cad65c018955bab47e5">FunctionWriter</a>(Function* w) : write(w) {}
<a name="l01937"></a>01937         };
<a name="l01938"></a>01938 
<a name="l01945"></a>01945         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> OStream&gt;
<a name="l01946"></a><a class="code" href="../../d5/deb/structoption_1_1PrintUsageImplementation_1_1OStreamWriter.html">01946</a>         <span class="keyword">struct </span><a class="code" href="../../d5/deb/structoption_1_1PrintUsageImplementation_1_1OStreamWriter.html">OStreamWriter</a> : <span class="keyword">public</span> <a class="code" href="../../dd/d0b/structoption_1_1PrintUsageImplementation_1_1IStringWriter.html">IStringWriter</a> {
<a name="l01947"></a><a class="code" href="../../d5/deb/structoption_1_1PrintUsageImplementation_1_1OStreamWriter.html#a9b808696e204a834acd4362c62b9f4c1">01947</a>             OStream&amp; ostream;
<a name="l01948"></a>01948 
<a name="l01949"></a><a class="code" href="../../d5/deb/structoption_1_1PrintUsageImplementation_1_1OStreamWriter.html#a323890fba123ad476fa2471029fc7b23">01949</a>             <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="../../d5/deb/structoption_1_1PrintUsageImplementation_1_1OStreamWriter.html#a323890fba123ad476fa2471029fc7b23" title="Writes the given number of chars beginning at the given pointer somewhere.">operator()</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* str, <span class="keywordtype">int</span> size) {
<a name="l01950"></a>01950                 ostream.write(str, size);
<a name="l01951"></a>01951             }
<a name="l01952"></a>01952 
<a name="l01953"></a><a class="code" href="../../d5/deb/structoption_1_1PrintUsageImplementation_1_1OStreamWriter.html#abf38eb181267e96d86de1ea09ad22c3f">01953</a>             <a class="code" href="../../d5/deb/structoption_1_1PrintUsageImplementation_1_1OStreamWriter.html#abf38eb181267e96d86de1ea09ad22c3f">OStreamWriter</a>(OStream&amp; o) : ostream(o) {}
<a name="l01954"></a>01954         };
<a name="l01955"></a>01955 
<a name="l01962"></a>01962         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Temporary&gt;
<a name="l01963"></a><a class="code" href="../../d8/da8/structoption_1_1PrintUsageImplementation_1_1TemporaryWriter.html">01963</a>         <span class="keyword">struct </span><a class="code" href="../../d8/da8/structoption_1_1PrintUsageImplementation_1_1TemporaryWriter.html">TemporaryWriter</a> : <span class="keyword">public</span> <a class="code" href="../../dd/d0b/structoption_1_1PrintUsageImplementation_1_1IStringWriter.html">IStringWriter</a> {
<a name="l01964"></a><a class="code" href="../../d8/da8/structoption_1_1PrintUsageImplementation_1_1TemporaryWriter.html#a91d54cfcea7bb4072072506d46cc2cc8">01964</a>             <span class="keyword">const</span> Temporary&amp; userstream;
<a name="l01965"></a>01965 
<a name="l01966"></a><a class="code" href="../../d8/da8/structoption_1_1PrintUsageImplementation_1_1TemporaryWriter.html#a674751ddfff63852b36c754878276b02">01966</a>             <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="../../d8/da8/structoption_1_1PrintUsageImplementation_1_1TemporaryWriter.html#a674751ddfff63852b36c754878276b02" title="Writes the given number of chars beginning at the given pointer somewhere.">operator()</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* str, <span class="keywordtype">int</span> size) {
<a name="l01967"></a>01967                 userstream.write(str, size);
<a name="l01968"></a>01968             }
<a name="l01969"></a>01969 
<a name="l01970"></a><a class="code" href="../../d8/da8/structoption_1_1PrintUsageImplementation_1_1TemporaryWriter.html#a0c65740b5a897ca2a2465d1c112882a8">01970</a>             <a class="code" href="../../d8/da8/structoption_1_1PrintUsageImplementation_1_1TemporaryWriter.html#a0c65740b5a897ca2a2465d1c112882a8">TemporaryWriter</a>(<span class="keyword">const</span> Temporary&amp; u) : userstream(u) {}
<a name="l01971"></a>01971         };
<a name="l01972"></a>01972 
<a name="l01981"></a>01981         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Syscall&gt;
<a name="l01982"></a><a class="code" href="../../d3/d44/structoption_1_1PrintUsageImplementation_1_1SyscallWriter.html">01982</a>         <span class="keyword">struct </span><a class="code" href="../../d3/d44/structoption_1_1PrintUsageImplementation_1_1SyscallWriter.html">SyscallWriter</a> : <span class="keyword">public</span> <a class="code" href="../../dd/d0b/structoption_1_1PrintUsageImplementation_1_1IStringWriter.html">IStringWriter</a> {
<a name="l01983"></a><a class="code" href="../../d3/d44/structoption_1_1PrintUsageImplementation_1_1SyscallWriter.html#adc72b04cd74c69d0219b8b26589b8e5e">01983</a>             Syscall* write;
<a name="l01984"></a><a class="code" href="../../d3/d44/structoption_1_1PrintUsageImplementation_1_1SyscallWriter.html#ae79409e3f85f8dbaa7ef87bb8d7fcf8a">01984</a>             <span class="keywordtype">int</span> fd;
<a name="l01985"></a>01985 
<a name="l01986"></a><a class="code" href="../../d3/d44/structoption_1_1PrintUsageImplementation_1_1SyscallWriter.html#a61c1c010d9b67affd5f1208f0a3e9cf0">01986</a>             <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="../../d3/d44/structoption_1_1PrintUsageImplementation_1_1SyscallWriter.html#a61c1c010d9b67affd5f1208f0a3e9cf0" title="Writes the given number of chars beginning at the given pointer somewhere.">operator()</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* str, <span class="keywordtype">int</span> size) {
<a name="l01987"></a>01987                 (*write)(fd, str, size);
<a name="l01988"></a>01988             }
<a name="l01989"></a>01989 
<a name="l01990"></a><a class="code" href="../../d3/d44/structoption_1_1PrintUsageImplementation_1_1SyscallWriter.html#ae4f8677dbd79b0a9238368e28014701a">01990</a>             <a class="code" href="../../d3/d44/structoption_1_1PrintUsageImplementation_1_1SyscallWriter.html#ae4f8677dbd79b0a9238368e28014701a">SyscallWriter</a>(Syscall* w, <span class="keywordtype">int</span> f) : write(w), fd(f) {}
<a name="l01991"></a>01991         };
<a name="l01992"></a>01992 
<a name="l01998"></a>01998         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Function, <span class="keyword">typename</span> Stream&gt;
<a name="l01999"></a><a class="code" href="../../de/d60/structoption_1_1PrintUsageImplementation_1_1StreamWriter.html">01999</a>         <span class="keyword">struct </span><a class="code" href="../../de/d60/structoption_1_1PrintUsageImplementation_1_1StreamWriter.html">StreamWriter</a> : <span class="keyword">public</span> <a class="code" href="../../dd/d0b/structoption_1_1PrintUsageImplementation_1_1IStringWriter.html">IStringWriter</a> {
<a name="l02000"></a><a class="code" href="../../de/d60/structoption_1_1PrintUsageImplementation_1_1StreamWriter.html#a6f54abc9a3f7f00206d87a3619713954">02000</a>             Function* fwrite;
<a name="l02001"></a><a class="code" href="../../de/d60/structoption_1_1PrintUsageImplementation_1_1StreamWriter.html#ab4bfd31b1c37376505ccd4230f7f7ad9">02001</a>             Stream* stream;
<a name="l02002"></a>02002 
<a name="l02003"></a><a class="code" href="../../de/d60/structoption_1_1PrintUsageImplementation_1_1StreamWriter.html#ae39bc6378c22d24a490104b7764c37b7">02003</a>             <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="../../de/d60/structoption_1_1PrintUsageImplementation_1_1StreamWriter.html#ae39bc6378c22d24a490104b7764c37b7" title="Writes the given number of chars beginning at the given pointer somewhere.">operator()</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* str, <span class="keywordtype">int</span> size) {
<a name="l02004"></a>02004                 (*fwrite)(str, size, 1, stream);
<a name="l02005"></a>02005             }
<a name="l02006"></a>02006 
<a name="l02007"></a><a class="code" href="../../de/d60/structoption_1_1PrintUsageImplementation_1_1StreamWriter.html#aa6ab48848dcbeb9e2cbde5d05ec35005">02007</a>             <a class="code" href="../../de/d60/structoption_1_1PrintUsageImplementation_1_1StreamWriter.html#aa6ab48848dcbeb9e2cbde5d05ec35005">StreamWriter</a>(Function* w, Stream* <a class="code" href="../../dc/df2/Slices_8h.html#a0b582b5b17da9bbc95ef1b5d0c08bd93aa8e9307350b1e20521f37dfe5268df55">s</a>) : fwrite(w), stream(s) {}
<a name="l02008"></a>02008         };
<a name="l02009"></a>02009 
<a name="l02014"></a><a class="code" href="../../da/dfb/structoption_1_1PrintUsageImplementation.html#a0680dd84366df82398e30e4ccbd27ac0">02014</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="../../da/dfb/structoption_1_1PrintUsageImplementation.html#a0680dd84366df82398e30e4ccbd27ac0">upmax</a>(<span class="keywordtype">int</span>&amp; i1, <span class="keywordtype">int</span> i2) { i1 = (i1 &gt;= i2 ? i1 : i2); }
<a name="l02015"></a>02015 
<a name="l02031"></a><a class="code" href="../../da/dfb/structoption_1_1PrintUsageImplementation.html#a4136c574bba35ea1f478e0b6d7022367">02031</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="../../da/dfb/structoption_1_1PrintUsageImplementation.html#a4136c574bba35ea1f478e0b6d7022367">indent</a>(<a class="code" href="../../dd/d0b/structoption_1_1PrintUsageImplementation_1_1IStringWriter.html">IStringWriter</a>&amp; write, <span class="keywordtype">int</span>&amp; x, <span class="keywordtype">int</span> want_x) {
<a name="l02032"></a>02032             <span class="keywordtype">int</span> indent = want_x - x;
<a name="l02033"></a>02033             <span class="keywordflow">if</span> (indent &lt; 0) {
<a name="l02034"></a>02034                 write(<span class="stringliteral">&quot;\n&quot;</span>, 1);
<a name="l02035"></a>02035                 indent = want_x;
<a name="l02036"></a>02036             }
<a name="l02037"></a>02037 
<a name="l02038"></a>02038             <span class="keywordflow">if</span> (indent &gt; 0) {
<a name="l02039"></a>02039                 <span class="keywordtype">char</span> space = <span class="charliteral">&apos; &apos;</span>;
<a name="l02040"></a>02040                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; indent; ++i)
<a name="l02041"></a>02041                     write(&amp;space, 1);
<a name="l02042"></a>02042                 x = want_x;
<a name="l02043"></a>02043             }
<a name="l02044"></a>02044         }
<a name="l02045"></a>02045 
<a name="l02065"></a><a class="code" href="../../da/dfb/structoption_1_1PrintUsageImplementation.html#a41bfaabdf21e68877f3030d36acc0798">02065</a>         <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="../../da/dfb/structoption_1_1PrintUsageImplementation.html#a41bfaabdf21e68877f3030d36acc0798" title="Returns true if ch is the unicode code point of a wide character.">isWideChar</a>(<span class="keywordtype">unsigned</span> ch) {
<a name="l02066"></a>02066             <span class="keywordflow">if</span> (ch == 0x303F)
<a name="l02067"></a>02067                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02068"></a>02068 
<a name="l02069"></a>02069             <span class="keywordflow">return</span> ((0x1100 &lt;= ch &amp;&amp; ch &lt;= 0x115F) ||
<a name="l02070"></a>02070                     (0x2329 &lt;= ch &amp;&amp; ch &lt;= 0x232A) ||
<a name="l02071"></a>02071                     (0x2E80 &lt;= ch &amp;&amp; ch &lt;= 0xA4C6) ||
<a name="l02072"></a>02072                     (0xA960 &lt;= ch &amp;&amp; ch &lt;= 0xA97C) ||
<a name="l02073"></a>02073                     (0xAC00 &lt;= ch &amp;&amp; ch &lt;= 0xD7FB) ||
<a name="l02074"></a>02074                     (0xF900 &lt;= ch &amp;&amp; ch &lt;= 0xFAFF) ||
<a name="l02075"></a>02075                     (0xFE10 &lt;= ch &amp;&amp; ch &lt;= 0xFE6B) ||
<a name="l02076"></a>02076                     (0xFF01 &lt;= ch &amp;&amp; ch &lt;= 0xFF60) ||
<a name="l02077"></a>02077                     (0xFFE0 &lt;= ch &amp;&amp; ch &lt;= 0xFFE6) || (0x1B000 &lt;= ch));
<a name="l02078"></a>02078         }
<a name="l02079"></a>02079 
<a name="l02131"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html">02131</a>         <span class="keyword">class </span><a class="code" href="../../de/df0/utilities_8h.html#ad8ce4efaa307683d3d763b37b4711c53">API</a> <a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html">LinePartIterator</a> {
<a name="l02132"></a>02132             <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a>*
<a name="l02133"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#ac043238fbc8d0700a9d80ccbea42275c">02133</a>                 tablestart; 
<a name="l02134"></a>02134             <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a>*
<a name="l02135"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a16319411b47f613f2277db4e9a29dbb5">02135</a>                 rowdesc; 
<a name="l02136"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a5e82df3342ea1dee5c6c59856fdd24d4">02136</a>             <span class="keyword">const</span> <span class="keywordtype">char</span>* rowstart; 
<a name="l02137"></a>02137 
<a name="l02138"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a4a9ef2897c52f3a3563545ac8de5b133">02138</a>             <span class="keyword">const</span> <span class="keywordtype">char</span>* ptr; 
<a name="l02139"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#ac406a1fcc118e5b749f681a6f96b3eb0">02139</a>             <span class="keywordtype">int</span> col;         
<a name="l02140"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#ac31b91c14a94073f6eebc31dc91b47f2">02140</a>             <span class="keywordtype">int</span> len; 
<a name="l02141"></a>02141 
<a name="l02142"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a80e35222723182a8245be699c3b2f141">02142</a>             <span class="keywordtype">int</span> screenlen; 
<a name="l02143"></a>02143 
<a name="l02144"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#ac76e736568519801a42ddb9069f0a6a7">02144</a>             <span class="keywordtype">int</span> max_line_in_block; 
<a name="l02145"></a>02145 
<a name="l02146"></a>02146 
<a name="l02147"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#af02b54fea121ef1851d11a8d9fa261dc">02147</a>             <span class="keywordtype">int</span> line_in_block; 
<a name="l02148"></a>02148 
<a name="l02149"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a1b65920c801187f2cd81de713a332cb4">02149</a>             <span class="keywordtype">int</span> target_line_in_block; 
<a name="l02150"></a>02150 
<a name="l02151"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a1538b520d8c7f40d9e35f0289805041d">02151</a>             <span class="keywordtype">bool</span> hit_target_line; 
<a name="l02152"></a>02152 
<a name="l02153"></a>02153 
<a name="l02154"></a>02154 
<a name="l02160"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a6113f810ad692ef33057145008c937be">02160</a>             <span class="keywordtype">void</span> <a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a6113f810ad692ef33057145008c937be" title="Determines the byte and character lengths of the part at ptr and stores them in len...">update_length</a>() {
<a name="l02161"></a>02161                 screenlen = 0;
<a name="l02162"></a>02162                 <span class="keywordflow">for</span> (len = 0; ptr[len] != 0 &amp;&amp; ptr[len] != <span class="charliteral">&apos;\v&apos;</span> &amp;&amp;
<a name="l02163"></a>02163                               ptr[len] != <span class="charliteral">&apos;\t&apos;</span> &amp;&amp; ptr[len] != <span class="charliteral">&apos;\n&apos;</span>;
<a name="l02164"></a>02164                      ++len) {
<a name="l02165"></a>02165                     ++screenlen;
<a name="l02166"></a>02166                     <span class="keywordtype">unsigned</span> ch = (<span class="keywordtype">unsigned</span> char)ptr[len];
<a name="l02167"></a>02167                     <span class="keywordflow">if</span> (ch &gt; 0xC1) { <span class="comment">// everything &lt;= 0xC1 (yes, even 0xC1</span>
<a name="l02168"></a>02168                         <span class="comment">// itself) is not a valid UTF-8 start byte</span>
<a name="l02169"></a>02169                         <span class="comment">// int __builtin_clz (unsigned int x)</span>
<a name="l02170"></a>02170                         <span class="comment">// Returns the number of leading 0-bits in x, starting</span>
<a name="l02171"></a>02171                         <span class="comment">// at the most significant bit</span>
<a name="l02172"></a>02172                         <span class="keywordtype">unsigned</span> mask =
<a name="l02173"></a>02173                             (unsigned)-1 &gt;&gt; __builtin_clz(ch ^ 0xff);
<a name="l02174"></a>02174                         ch = ch &amp; mask; <span class="comment">// mask out length bits, we don&apos;t verify</span>
<a name="l02175"></a>02175                         <span class="comment">// their correctness</span>
<a name="l02176"></a>02176                         <span class="keywordflow">while</span> (((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)ptr[len + 1] ^ 0x80) &lt;=
<a name="l02177"></a>02177                                0x3F) { <span class="comment">// while next byte is continuation byte</span>
<a name="l02178"></a>02178                             ch = (ch &lt;&lt; 6) ^ (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)ptr[len + 1] ^
<a name="l02179"></a>02179                                  0x80; <span class="comment">// add continuation to char code</span>
<a name="l02180"></a>02180                             ++len;
<a name="l02181"></a>02181                         }
<a name="l02182"></a>02182                         <span class="comment">// ch is the decoded unicode code point</span>
<a name="l02183"></a>02183                         <span class="keywordflow">if</span> (ch &gt;= 0x1100 &amp;&amp; isWideChar(ch)) <span class="comment">// the test for</span>
<a name="l02184"></a>02184                                                             <span class="comment">// 0x1100 is here to</span>
<a name="l02185"></a>02185                                                             <span class="comment">// avoid the</span>
<a name="l02186"></a>02186                                                             <span class="comment">// function call in</span>
<a name="l02187"></a>02187                                                             <span class="comment">// the Latin case</span>
<a name="l02188"></a>02188                             ++screenlen;
<a name="l02189"></a>02189                     }
<a name="l02190"></a>02190                 }
<a name="l02191"></a>02191             }
<a name="l02192"></a>02192 
<a name="l02193"></a>02193           <span class="keyword">public</span>:
<a name="l02195"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a8a61fef9ba907fd4e10ff0fd772ee5e7">02195</a>             <a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html">LinePartIterator</a>(<span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[])
<a name="l02196"></a>02196                 : tablestart(usage), rowdesc(0), rowstart(0), ptr(0), col(-1),
<a name="l02197"></a>02197                   len(0), max_line_in_block(0), line_in_block(0),
<a name="l02198"></a>02198                   target_line_in_block(0), hit_target_line(true) {}
<a name="l02199"></a>02199 
<a name="l02207"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#afe43ca12d399ed3c871e4dc5bf63356e">02207</a>             <span class="keywordtype">bool</span> <a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#afe43ca12d399ed3c871e4dc5bf63356e" title="Moves iteration to the next table (if any). Has to be called once on a new LinePartIterator...">nextTable</a>() {
<a name="l02208"></a>02208                 <span class="comment">// If this is NOT the first time nextTable() is called after the</span>
<a name="l02209"></a>02209                 <span class="comment">// constructor,</span>
<a name="l02210"></a>02210                 <span class="comment">// then skip to the next table break (i.e. a Descriptor with</span>
<a name="l02211"></a>02211                 <span class="comment">// help == 0)</span>
<a name="l02212"></a>02212                 <span class="keywordflow">if</span> (rowdesc != 0) {
<a name="l02213"></a>02213                     <span class="keywordflow">while</span> (tablestart-&gt;help != 0 &amp;&amp; tablestart-&gt;shortopt != 0)
<a name="l02214"></a>02214                         ++tablestart;
<a name="l02215"></a>02215                 }
<a name="l02216"></a>02216 
<a name="l02217"></a>02217                 <span class="comment">// Find the next table after the break (if any)</span>
<a name="l02218"></a>02218                 <span class="keywordflow">while</span> (tablestart-&gt;help == 0 &amp;&amp; tablestart-&gt;shortopt != 0)
<a name="l02219"></a>02219                     ++tablestart;
<a name="l02220"></a>02220 
<a name="l02221"></a>02221                 restartTable();
<a name="l02222"></a>02222                 <span class="keywordflow">return</span> rowstart != 0;
<a name="l02223"></a>02223             }
<a name="l02224"></a>02224 
<a name="l02228"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a0cbe8ed79ab4958a70b957598dd76fa6">02228</a>             <span class="keywordtype">void</span> <a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a0cbe8ed79ab4958a70b957598dd76fa6" title="Reset iteration to the beginning of the current table.">restartTable</a>() {
<a name="l02229"></a>02229                 rowdesc = tablestart;
<a name="l02230"></a>02230                 rowstart = tablestart-&gt;help;
<a name="l02231"></a>02231                 ptr = 0;
<a name="l02232"></a>02232             }
<a name="l02233"></a>02233 
<a name="l02241"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a55d5c3e50f9c1d8cd48f518899a5a48c">02241</a>             <span class="keywordtype">bool</span> <a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a55d5c3e50f9c1d8cd48f518899a5a48c" title="Moves iteration to the next row (if any). Has to be called once after each call to...">nextRow</a>() {
<a name="l02242"></a>02242                 <span class="keywordflow">if</span> (ptr == 0) {
<a name="l02243"></a>02243                     restartRow();
<a name="l02244"></a>02244                     <span class="keywordflow">return</span> rowstart != 0;
<a name="l02245"></a>02245                 }
<a name="l02246"></a>02246 
<a name="l02247"></a>02247                 <span class="keywordflow">while</span> (*ptr != 0 &amp;&amp; *ptr != <span class="charliteral">&apos;\n&apos;</span>)
<a name="l02248"></a>02248                     ++ptr;
<a name="l02249"></a>02249 
<a name="l02250"></a>02250                 <span class="keywordflow">if</span> (*ptr == 0) {
<a name="l02251"></a>02251                     <span class="keywordflow">if</span> ((rowdesc + 1)-&gt;help == 0) <span class="comment">// table break</span>
<a name="l02252"></a>02252                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02253"></a>02253 
<a name="l02254"></a>02254                     ++rowdesc;
<a name="l02255"></a>02255                     rowstart = rowdesc-&gt;help;
<a name="l02256"></a>02256                 } <span class="keywordflow">else</span> { <span class="comment">// if (*ptr == &apos;\n&apos;)</span>
<a name="l02257"></a>02257                     rowstart = ptr + 1;
<a name="l02258"></a>02258                 }
<a name="l02259"></a>02259 
<a name="l02260"></a>02260                 restartRow();
<a name="l02261"></a>02261                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02262"></a>02262             }
<a name="l02263"></a>02263 
<a name="l02267"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a96c448939f33a811174ea7b5addb312e">02267</a>             <span class="keywordtype">void</span> <a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a96c448939f33a811174ea7b5addb312e" title="Reset iteration to the beginning of the current row.">restartRow</a>() {
<a name="l02268"></a>02268                 ptr = rowstart;
<a name="l02269"></a>02269                 col = -1;
<a name="l02270"></a>02270                 len = 0;
<a name="l02271"></a>02271                 screenlen = 0;
<a name="l02272"></a>02272                 max_line_in_block = 0;
<a name="l02273"></a>02273                 line_in_block = 0;
<a name="l02274"></a>02274                 target_line_in_block = 0;
<a name="l02275"></a>02275                 hit_target_line = <span class="keyword">true</span>;
<a name="l02276"></a>02276             }
<a name="l02277"></a>02277 
<a name="l02287"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a58b8743da57de2d108472eee60324df6">02287</a>             <span class="keywordtype">bool</span> <a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a58b8743da57de2d108472eee60324df6" title="Moves iteration to the next part (if any). Has to be called once after each call...">next</a>() {
<a name="l02288"></a>02288                 <span class="keywordflow">if</span> (ptr == 0)
<a name="l02289"></a>02289                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02290"></a>02290 
<a name="l02291"></a>02291                 <span class="keywordflow">if</span> (col == -1) {
<a name="l02292"></a>02292                     col = 0;
<a name="l02293"></a>02293                     update_length();
<a name="l02294"></a>02294                     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02295"></a>02295                 }
<a name="l02296"></a>02296 
<a name="l02297"></a>02297                 ptr += len;
<a name="l02298"></a>02298                 <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l02299"></a>02299                     <span class="keywordflow">switch</span> (*ptr) {
<a name="l02300"></a>02300                     <span class="keywordflow">case</span> <span class="charliteral">&apos;\v&apos;</span>:
<a name="l02301"></a>02301                         upmax(max_line_in_block, ++line_in_block);
<a name="l02302"></a>02302                         ++ptr;
<a name="l02303"></a>02303                         <span class="keywordflow">break</span>;
<a name="l02304"></a>02304                     <span class="keywordflow">case</span> <span class="charliteral">&apos;\t&apos;</span>:
<a name="l02305"></a>02305                         <span class="keywordflow">if</span> (!hit_target_line) { <span class="comment">// if previous column did not</span>
<a name="l02306"></a>02306                                                 <span class="comment">// have the targetline</span>
<a name="l02307"></a>02307                                                 <span class="comment">// then &quot;insert&quot; a 0-length part</span>
<a name="l02308"></a>02308                             update_length();
<a name="l02309"></a>02309                             hit_target_line = <span class="keyword">true</span>;
<a name="l02310"></a>02310                             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02311"></a>02311                         }
<a name="l02312"></a>02312 
<a name="l02313"></a>02313                         hit_target_line = <span class="keyword">false</span>;
<a name="l02314"></a>02314                         line_in_block = 0;
<a name="l02315"></a>02315                         ++col;
<a name="l02316"></a>02316                         ++ptr;
<a name="l02317"></a>02317                         <span class="keywordflow">break</span>;
<a name="l02318"></a>02318                     <span class="keywordflow">case</span> 0:
<a name="l02319"></a>02319                     <span class="keywordflow">case</span> <span class="charliteral">&apos;\n&apos;</span>:
<a name="l02320"></a>02320                         <span class="keywordflow">if</span> (!hit_target_line) { <span class="comment">// if previous column did not</span>
<a name="l02321"></a>02321                                                 <span class="comment">// have the targetline</span>
<a name="l02322"></a>02322                                                 <span class="comment">// then &quot;insert&quot; a 0-length part</span>
<a name="l02323"></a>02323                             update_length();
<a name="l02324"></a>02324                             hit_target_line = <span class="keyword">true</span>;
<a name="l02325"></a>02325                             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02326"></a>02326                         }
<a name="l02327"></a>02327 
<a name="l02328"></a>02328                         <span class="keywordflow">if</span> (++target_line_in_block &gt; max_line_in_block) {
<a name="l02329"></a>02329                             update_length();
<a name="l02330"></a>02330                             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02331"></a>02331                         }
<a name="l02332"></a>02332 
<a name="l02333"></a>02333                         hit_target_line = <span class="keyword">false</span>;
<a name="l02334"></a>02334                         line_in_block = 0;
<a name="l02335"></a>02335                         col = 0;
<a name="l02336"></a>02336                         ptr = rowstart;
<a name="l02337"></a>02337                         <span class="keywordflow">continue</span>;
<a name="l02338"></a>02338                     <span class="keywordflow">default</span>:
<a name="l02339"></a>02339                         ++ptr;
<a name="l02340"></a>02340                         <span class="keywordflow">continue</span>;
<a name="l02341"></a>02341                     } <span class="comment">// switch</span>
<a name="l02342"></a>02342 
<a name="l02343"></a>02343                     <span class="keywordflow">if</span> (line_in_block == target_line_in_block) {
<a name="l02344"></a>02344                         update_length();
<a name="l02345"></a>02345                         hit_target_line = <span class="keyword">true</span>;
<a name="l02346"></a>02346                         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02347"></a>02347                     }
<a name="l02348"></a>02348                 } <span class="comment">// while</span>
<a name="l02349"></a>02349             }
<a name="l02350"></a>02350 
<a name="l02355"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#afa41382acabcd37ca70f7e8b9994b8c0">02355</a>             <span class="keywordtype">int</span> <a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#afa41382acabcd37ca70f7e8b9994b8c0" title="Returns the index (counting from 0) of the column in which the part pointed to by...">column</a>() { <span class="keywordflow">return</span> col; }
<a name="l02356"></a>02356 
<a name="l02362"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a8ad1201d95bf0bd9453a731da8c15a10">02362</a>             <span class="keywordtype">int</span> <a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a8ad1201d95bf0bd9453a731da8c15a10" title="Returns the index (counting from 0) of the line within the current column this part...">line</a>() {
<a name="l02363"></a>02363                 <span class="keywordflow">return</span> target_line_in_block; <span class="comment">// NOT line_in_block !!! It would</span>
<a name="l02364"></a>02364                                              <span class="comment">// be wrong if !hit_target_line</span>
<a name="l02365"></a>02365             }
<a name="l02366"></a>02366 
<a name="l02371"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a557e521cb41e951a34df2737d25f9dce">02371</a>             <span class="keywordtype">int</span> <a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a557e521cb41e951a34df2737d25f9dce" title="Returns the length of the part pointed to by data() in raw chars (not UTF-8 characters)...">length</a>() { <span class="keywordflow">return</span> len; }
<a name="l02372"></a>02372 
<a name="l02379"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a03b6fedfe805d7fc73216da5cd33270e">02379</a>             <span class="keywordtype">int</span> <a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a03b6fedfe805d7fc73216da5cd33270e" title="Returns the width in screen columns of the part pointed to by data(). Takes multi-byte...">screenLength</a>() { <span class="keywordflow">return</span> screenlen; }
<a name="l02380"></a>02380 
<a name="l02384"></a><a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#ada26229add63bd479c7877f2f8e32908">02384</a>             <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#ada26229add63bd479c7877f2f8e32908" title="Returns the current part of the iteration.">data</a>() { <span class="keywordflow">return</span> ptr; }
<a name="l02385"></a>02385         };
<a name="l02386"></a>02386 
<a name="l02418"></a><a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html">02418</a>         <span class="keyword">class </span><a class="code" href="../../de/df0/utilities_8h.html#ad8ce4efaa307683d3d763b37b4711c53">API</a> <a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html">LineWrapper</a> {
<a name="l02419"></a><a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#ac47be76ba68b2e70f5cc6285c8e0fa6a">02419</a>             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> bufmask = 15; 
<a name="l02420"></a>02420 
<a name="l02423"></a><a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a94c638feb65ec3bea97a80f944e532af">02423</a>             <span class="keywordtype">int</span> lenbuf[bufmask + 1];
<a name="l02427"></a><a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#abd9a32967913817ef8266bcf8af3e973">02427</a>             <span class="keyword">const</span> <span class="keywordtype">char</span>* datbuf[bufmask + 1];
<a name="l02437"></a><a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#acf828ad4ee388c881967142866d7d8b9">02437</a>             <span class="keywordtype">int</span> x;
<a name="l02441"></a><a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a535a97a3d4669e873ba1700215d6b7e7">02441</a>             <span class="keywordtype">int</span> width;
<a name="l02442"></a><a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a5e2107b64c4a785fb92fca3f99e04c6e">02442</a>             <span class="keywordtype">int</span> head; 
<a name="l02443"></a><a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a64dbc7e6c0858a9210ea1f39ce85084e">02443</a>             <span class="keywordtype">int</span> tail; 
<a name="l02444"></a>02444 
<a name="l02445"></a>02445 
<a name="l02457"></a><a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a97de335317942101262413a35f639b18">02457</a>             <span class="keywordtype">bool</span> wrote_something;
<a name="l02458"></a>02458 
<a name="l02459"></a><a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a9cd367ca1d308458366be2ebbd018ebe">02459</a>             <span class="keywordtype">bool</span> <a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a9cd367ca1d308458366be2ebbd018ebe">buf_empty</a>() { <span class="keywordflow">return</span> ((tail + 1) &amp; bufmask) == head; }
<a name="l02460"></a>02460 
<a name="l02461"></a><a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#ac814c95dcda4174b29e2f24c6bb13519">02461</a>             <span class="keywordtype">bool</span> <a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#ac814c95dcda4174b29e2f24c6bb13519">buf_full</a>() { <span class="keywordflow">return</span> tail == head; }
<a name="l02462"></a>02462 
<a name="l02463"></a><a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a43e2f45da4f29cc1eda7bf1f38a63806">02463</a>             <span class="keywordtype">void</span> <a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a43e2f45da4f29cc1eda7bf1f38a63806">buf_store</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* data, <span class="keywordtype">int</span> len) {
<a name="l02464"></a>02464                 lenbuf[head] = len;
<a name="l02465"></a>02465                 datbuf[head] = data;
<a name="l02466"></a>02466                 head = (head + 1) &amp; bufmask;
<a name="l02467"></a>02467             }
<a name="l02468"></a>02468 
<a name="l02470"></a><a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a2e0ef4f940413addf063ad7e429c6556">02470</a>             <span class="keywordtype">void</span> <a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a2e0ef4f940413addf063ad7e429c6556" title="Call BEFORE reading ...buf[tail].">buf_next</a>() { tail = (tail + 1) &amp; bufmask; }
<a name="l02471"></a>02471 
<a name="l02477"></a><a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a5b27b788033f4d6617a910da8cbcd511">02477</a>             <span class="keywordtype">void</span> <a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a5b27b788033f4d6617a910da8cbcd511" title="Writes (data,len) into the ring buffer. If the buffer is full, a single line is flushed...">output</a>(<a class="code" href="../../dd/d0b/structoption_1_1PrintUsageImplementation_1_1IStringWriter.html">IStringWriter</a>&amp; write, <span class="keyword">const</span> <span class="keywordtype">char</span>* data, <span class="keywordtype">int</span> len) {
<a name="l02478"></a>02478                 <span class="keywordflow">if</span> (buf_full())
<a name="l02479"></a>02479                     write_one_line(write);
<a name="l02480"></a>02480 
<a name="l02481"></a>02481                 buf_store(data, len);
<a name="l02482"></a>02482             }
<a name="l02483"></a>02483 
<a name="l02488"></a><a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a246494d38e76d7f65a70f1d0867dc42f">02488</a>             <span class="keywordtype">void</span> <a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a246494d38e76d7f65a70f1d0867dc42f" title="Writes a single line of output from the buffer to write.">write_one_line</a>(<a class="code" href="../../dd/d0b/structoption_1_1PrintUsageImplementation_1_1IStringWriter.html">IStringWriter</a>&amp; write) {
<a name="l02489"></a>02489                 <span class="keywordflow">if</span> (wrote_something) { <span class="comment">// if we already wrote something, we need</span>
<a name="l02490"></a>02490                                        <span class="comment">// to start a new line</span>
<a name="l02491"></a>02491                     write(<span class="stringliteral">&quot;\n&quot;</span>, 1);
<a name="l02492"></a>02492                     <span class="keywordtype">int</span> _ = 0;
<a name="l02493"></a>02493                     indent(write, _, x);
<a name="l02494"></a>02494                 }
<a name="l02495"></a>02495 
<a name="l02496"></a>02496                 <span class="keywordflow">if</span> (!buf_empty()) {
<a name="l02497"></a>02497                     buf_next();
<a name="l02498"></a>02498                     write(datbuf[tail], lenbuf[tail]);
<a name="l02499"></a>02499                 }
<a name="l02500"></a>02500 
<a name="l02501"></a>02501                 wrote_something = <span class="keyword">true</span>;
<a name="l02502"></a>02502             }
<a name="l02503"></a>02503 
<a name="l02504"></a>02504           <span class="keyword">public</span>:
<a name="l02513"></a><a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a9383db9fd3fb18ce091db63ce0b149fd">02513</a>             <span class="keywordtype">void</span> <a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a9383db9fd3fb18ce091db63ce0b149fd" title="Writes out all remaining data from the LineWrapper using write. Unlike process()...">flush</a>(<a class="code" href="../../dd/d0b/structoption_1_1PrintUsageImplementation_1_1IStringWriter.html">IStringWriter</a>&amp; write) {
<a name="l02514"></a>02514                 <span class="keywordflow">if</span> (buf_empty())
<a name="l02515"></a>02515                     <span class="keywordflow">return</span>;
<a name="l02516"></a>02516                 <span class="keywordtype">int</span> _ = 0;
<a name="l02517"></a>02517                 indent(write, _, x);
<a name="l02518"></a>02518                 wrote_something = <span class="keyword">false</span>;
<a name="l02519"></a>02519                 <span class="keywordflow">while</span> (!buf_empty())
<a name="l02520"></a>02520                     write_one_line(write);
<a name="l02521"></a>02521                 write(<span class="stringliteral">&quot;\n&quot;</span>, 1);
<a name="l02522"></a>02522             }
<a name="l02523"></a>02523 
<a name="l02548"></a><a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#add20eca40865ad892d6c28b412ac14d5">02548</a>             <span class="keywordtype">void</span> <a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#add20eca40865ad892d6c28b412ac14d5" title="Process, wrap and output the next piece of data.">process</a>(<a class="code" href="../../dd/d0b/structoption_1_1PrintUsageImplementation_1_1IStringWriter.html">IStringWriter</a>&amp; write, <span class="keyword">const</span> <span class="keywordtype">char</span>* data, <span class="keywordtype">int</span> len) {
<a name="l02549"></a>02549                 wrote_something = <span class="keyword">false</span>;
<a name="l02550"></a>02550 
<a name="l02551"></a>02551                 <span class="keywordflow">while</span> (len &gt; 0) {
<a name="l02552"></a>02552                     <span class="keywordflow">if</span> (len &lt;= width) { <span class="comment">// quick test that works because</span>
<a name="l02553"></a>02553                         <span class="comment">// utf8width &lt;= len (all wide chars have</span>
<a name="l02554"></a>02554                         <span class="comment">// at least 2 bytes)</span>
<a name="l02555"></a>02555                         output(write, data, len);
<a name="l02556"></a>02556                         len = 0;
<a name="l02557"></a>02557                     } <span class="keywordflow">else</span> { <span class="comment">// if (len &gt; width)  it&apos;s possible (but not</span>
<a name="l02558"></a>02558                              <span class="comment">// guaranteed) that utf8len &gt; width</span>
<a name="l02559"></a>02559                         <span class="keywordtype">int</span> utf8width = 0;
<a name="l02560"></a>02560                         <span class="keywordtype">int</span> maxi = 0;
<a name="l02561"></a>02561                         <span class="keywordflow">while</span> (maxi &lt; len &amp;&amp; utf8width &lt; width) {
<a name="l02562"></a>02562                             <span class="keywordtype">int</span> charbytes = 1;
<a name="l02563"></a>02563                             <span class="keywordtype">unsigned</span> ch = (<span class="keywordtype">unsigned</span> char)data[maxi];
<a name="l02564"></a>02564                             <span class="keywordflow">if</span> (ch &gt; 0xC1) { <span class="comment">// everything &lt;= 0xC1 (yes, even</span>
<a name="l02565"></a>02565                                 <span class="comment">// 0xC1 itself) is not a valid</span>
<a name="l02566"></a>02566                                 <span class="comment">// UTF-8 start byte</span>
<a name="l02567"></a>02567                                 <span class="comment">// int __builtin_clz (unsigned int x)</span>
<a name="l02568"></a>02568                                 <span class="comment">// Returns the number of leading 0-bits in x,</span>
<a name="l02569"></a>02569                                 <span class="comment">// starting at the most significant bit</span>
<a name="l02570"></a>02570                                 <span class="keywordtype">unsigned</span> mask =
<a name="l02571"></a>02571                                     (unsigned)-1 &gt;&gt; __builtin_clz(ch ^ 0xff);
<a name="l02572"></a>02572                                 ch = ch &amp; mask; <span class="comment">// mask out length bits, we</span>
<a name="l02573"></a>02573                                 <span class="comment">// don&apos;t verify their</span>
<a name="l02574"></a>02574                                 <span class="comment">// correctness</span>
<a name="l02575"></a>02575                                 <span class="keywordflow">while</span> ((maxi + charbytes &lt; len) &amp;&amp; <span class="comment">//</span>
<a name="l02576"></a>02576                                        (((<span class="keywordtype">unsigned</span> char)data[maxi + charbytes] ^
<a name="l02577"></a>02577                                          0x80) &lt;= 0x3F)) { <span class="comment">// while next byte is</span>
<a name="l02578"></a>02578                                                            <span class="comment">// continuation byte</span>
<a name="l02579"></a>02579                                     ch = (ch &lt;&lt; 6) ^
<a name="l02580"></a>02580                                          (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)data[maxi + charbytes] ^
<a name="l02581"></a>02581                                          0x80; <span class="comment">// add continuation to char code</span>
<a name="l02582"></a>02582                                     ++charbytes;
<a name="l02583"></a>02583                                 }
<a name="l02584"></a>02584                                 <span class="comment">// ch is the decoded unicode code point</span>
<a name="l02585"></a>02585                                 <span class="keywordflow">if</span> (ch &gt;= 0x1100 &amp;&amp;
<a name="l02586"></a>02586                                     isWideChar(ch)) { <span class="comment">// the test for 0x1100 is</span>
<a name="l02587"></a>02587                                                       <span class="comment">// here to avoid the</span>
<a name="l02588"></a>02588                                                       <span class="comment">// function call in the</span>
<a name="l02589"></a>02589                                                       <span class="comment">// Latin case</span>
<a name="l02590"></a>02590                                     <span class="keywordflow">if</span> (utf8width + 2 &gt; width)
<a name="l02591"></a>02591                                         <span class="keywordflow">break</span>;
<a name="l02592"></a>02592                                     ++utf8width;
<a name="l02593"></a>02593                                 }
<a name="l02594"></a>02594                             }
<a name="l02595"></a>02595                             ++utf8width;
<a name="l02596"></a>02596                             maxi += charbytes;
<a name="l02597"></a>02597                         }
<a name="l02598"></a>02598 
<a name="l02599"></a>02599                         <span class="comment">// data[maxi-1] is the last byte of the UTF-8 sequence</span>
<a name="l02600"></a>02600                         <span class="comment">// of the last character that fits</span>
<a name="l02601"></a>02601                         <span class="comment">// onto the 1st line. If maxi == len, all characters fit</span>
<a name="l02602"></a>02602                         <span class="comment">// on the line.</span>
<a name="l02603"></a>02603 
<a name="l02604"></a>02604                         <span class="keywordflow">if</span> (maxi == len) {
<a name="l02605"></a>02605                             output(write, data, len);
<a name="l02606"></a>02606                             len = 0;
<a name="l02607"></a>02607                         } <span class="keywordflow">else</span> { <span class="comment">// if (maxi &lt; len)  at least 1 character</span>
<a name="l02608"></a>02608                                  <span class="comment">// (data[maxi] that is) doesn&apos;t fit on the line</span>
<a name="l02609"></a>02609                             <span class="keywordtype">int</span> i;
<a name="l02610"></a>02610                             <span class="keywordflow">for</span> (i = maxi; i &gt;= 0; --i)
<a name="l02611"></a>02611                                 <span class="keywordflow">if</span> (data[i] == <span class="charliteral">&apos; &apos;</span>)
<a name="l02612"></a>02612                                     <span class="keywordflow">break</span>;
<a name="l02613"></a>02613 
<a name="l02614"></a>02614                             <span class="keywordflow">if</span> (i &gt;= 0) {
<a name="l02615"></a>02615                                 output(write, data, i);
<a name="l02616"></a>02616                                 data += i + 1;
<a name="l02617"></a>02617                                 len -= i + 1;
<a name="l02618"></a>02618                             } <span class="keywordflow">else</span> { <span class="comment">// did not find a space to split at =&gt;</span>
<a name="l02619"></a>02619                                      <span class="comment">// split before data[maxi]</span>
<a name="l02620"></a>02620                                      <span class="comment">// data[maxi] is always the beginning of a</span>
<a name="l02621"></a>02621                                      <span class="comment">// character, never a continuation byte</span>
<a name="l02622"></a>02622                                 output(write, data, maxi);
<a name="l02623"></a>02623                                 data += maxi;
<a name="l02624"></a>02624                                 len -= maxi;
<a name="l02625"></a>02625                             }
<a name="l02626"></a>02626                         }
<a name="l02627"></a>02627                     }
<a name="l02628"></a>02628                 }
<a name="l02629"></a>02629                 <span class="keywordflow">if</span> (!wrote_something) <span class="comment">// if we didn&apos;t already write something to</span>
<a name="l02630"></a>02630                                       <span class="comment">// make space in the buffer</span>
<a name="l02631"></a>02631                     write_one_line(
<a name="l02632"></a>02632                         write); <span class="comment">// write at most one line of actual output</span>
<a name="l02633"></a>02633             }
<a name="l02634"></a>02634 
<a name="l02642"></a><a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a288f16b6e928e9f54f48e13ff6817e95">02642</a>             <a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html">LineWrapper</a>(<span class="keywordtype">int</span> x1, <span class="keywordtype">int</span> x2)
<a name="l02643"></a>02643                 : x(x1), width(x2 - x1), head(0), tail(bufmask) {
<a name="l02644"></a>02644                 <span class="keywordflow">if</span> (width &lt; 2) <span class="comment">// because of wide characters we need at least</span>
<a name="l02645"></a>02645                                <span class="comment">// width 2 or the code breaks</span>
<a name="l02646"></a>02646                     width = 2;
<a name="l02647"></a>02647             }
<a name="l02648"></a>02648         };
<a name="l02649"></a>02649 
<a name="l02657"></a><a class="code" href="../../da/dfb/structoption_1_1PrintUsageImplementation.html#ab38c4198c5cccea2ccd992c8e014df70">02657</a>         <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="../../df/de0/namespaceoption.html#a13564b6055a677443dfe6cdcc86875a4" title="Outputs a nicely formatted usage string with support for multi-column formatting...">printUsage</a>(<a class="code" href="../../dd/d0b/structoption_1_1PrintUsageImplementation_1_1IStringWriter.html">IStringWriter</a>&amp; write, <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[],
<a name="l02658"></a>02658                                <span class="keywordtype">int</span> width = 80, <span class="comment">//</span>
<a name="l02659"></a>02659                                <span class="keywordtype">int</span> last_column_min_percent = 50,
<a name="l02660"></a>02660                                <span class="keywordtype">int</span> last_column_own_line_max_percent = 75) {
<a name="l02661"></a>02661             <span class="keywordflow">if</span> (width &lt; 1) <span class="comment">// protect against nonsense values</span>
<a name="l02662"></a>02662                 width = 80;
<a name="l02663"></a>02663 
<a name="l02664"></a>02664             <span class="keywordflow">if</span> (width &gt;
<a name="l02665"></a>02665                 10000) <span class="comment">// protect against overflow in the following computation</span>
<a name="l02666"></a>02666                 width = 10000;
<a name="l02667"></a>02667 
<a name="l02668"></a>02668             <span class="keywordtype">int</span> last_column_min_width =
<a name="l02669"></a>02669                 ((width * last_column_min_percent) + 50) / 100;
<a name="l02670"></a>02670             <span class="keywordtype">int</span> last_column_own_line_max_width =
<a name="l02671"></a>02671                 ((width * last_column_own_line_max_percent) + 50) / 100;
<a name="l02672"></a>02672             <span class="keywordflow">if</span> (last_column_own_line_max_width == 0)
<a name="l02673"></a>02673                 last_column_own_line_max_width = 1;
<a name="l02674"></a>02674 
<a name="l02675"></a>02675             <a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html">LinePartIterator</a> part(usage);
<a name="l02676"></a>02676             <span class="keywordflow">while</span> (part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#afe43ca12d399ed3c871e4dc5bf63356e" title="Moves iteration to the next table (if any). Has to be called once on a new LinePartIterator...">nextTable</a>()) {
<a name="l02677"></a>02677 
<a name="l02678"></a>02678                 <span class="comment">/***************** Determine column widths</span>
<a name="l02679"></a>02679 <span class="comment">                * *******************************/</span>
<a name="l02680"></a>02680 
<a name="l02681"></a>02681                 <span class="keyword">const</span> <span class="keywordtype">int</span> maxcolumns = 8; <span class="comment">// 8 columns are enough for everyone</span>
<a name="l02682"></a>02682                 <span class="keywordtype">int</span> col_width[maxcolumns];
<a name="l02683"></a>02683                 <span class="keywordtype">int</span> lastcolumn;
<a name="l02684"></a>02684                 <span class="keywordtype">int</span> leftwidth;
<a name="l02685"></a>02685                 <span class="keywordtype">int</span> overlong_column_threshold = 10000;
<a name="l02686"></a>02686                 <span class="keywordflow">do</span> {
<a name="l02687"></a>02687                     lastcolumn = 0;
<a name="l02688"></a>02688                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; maxcolumns; ++i)
<a name="l02689"></a>02689                         col_width[i] = 0;
<a name="l02690"></a>02690 
<a name="l02691"></a>02691                     part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a0cbe8ed79ab4958a70b957598dd76fa6" title="Reset iteration to the beginning of the current table.">restartTable</a>();
<a name="l02692"></a>02692                     <span class="keywordflow">while</span> (part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a55d5c3e50f9c1d8cd48f518899a5a48c" title="Moves iteration to the next row (if any). Has to be called once after each call to...">nextRow</a>()) {
<a name="l02693"></a>02693                         <span class="keywordflow">while</span> (part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a58b8743da57de2d108472eee60324df6" title="Moves iteration to the next part (if any). Has to be called once after each call...">next</a>()) {
<a name="l02694"></a>02694                             <span class="keywordflow">if</span> (part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#afa41382acabcd37ca70f7e8b9994b8c0" title="Returns the index (counting from 0) of the column in which the part pointed to by...">column</a>() &lt; maxcolumns) {
<a name="l02695"></a>02695                                 upmax(lastcolumn, part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#afa41382acabcd37ca70f7e8b9994b8c0" title="Returns the index (counting from 0) of the column in which the part pointed to by...">column</a>());
<a name="l02696"></a>02696                                 <span class="keywordflow">if</span> (part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a03b6fedfe805d7fc73216da5cd33270e" title="Returns the width in screen columns of the part pointed to by data(). Takes multi-byte...">screenLength</a>() &lt;
<a name="l02697"></a>02697                                     overlong_column_threshold)
<a name="l02698"></a>02698                                     <span class="comment">// We don&apos;t let rows that don&apos;t use table</span>
<a name="l02699"></a>02699                                     <span class="comment">// separators (\t or \v) influence</span>
<a name="l02700"></a>02700                                     <span class="comment">// the width of column 0. This allows the</span>
<a name="l02701"></a>02701                                     <span class="comment">// user to interject section headers</span>
<a name="l02702"></a>02702                                     <span class="comment">// or explanatory paragraphs that do not</span>
<a name="l02703"></a>02703                                     <span class="comment">// participate in the table layout.</span>
<a name="l02704"></a>02704                                     <span class="keywordflow">if</span> (part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#afa41382acabcd37ca70f7e8b9994b8c0" title="Returns the index (counting from 0) of the column in which the part pointed to by...">column</a>() &gt; 0 || part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a8ad1201d95bf0bd9453a731da8c15a10" title="Returns the index (counting from 0) of the line within the current column this part...">line</a>() &gt; 0 ||
<a name="l02705"></a>02705                                         part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#ada26229add63bd479c7877f2f8e32908" title="Returns the current part of the iteration.">data</a>()[part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a557e521cb41e951a34df2737d25f9dce" title="Returns the length of the part pointed to by data() in raw chars (not UTF-8 characters)...">length</a>()] == <span class="charliteral">&apos;\t&apos;</span> ||
<a name="l02706"></a>02706                                         part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#ada26229add63bd479c7877f2f8e32908" title="Returns the current part of the iteration.">data</a>()[part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a557e521cb41e951a34df2737d25f9dce" title="Returns the length of the part pointed to by data() in raw chars (not UTF-8 characters)...">length</a>()] == <span class="charliteral">&apos;\v&apos;</span>)
<a name="l02707"></a>02707                                         upmax(col_width[part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#afa41382acabcd37ca70f7e8b9994b8c0" title="Returns the index (counting from 0) of the column in which the part pointed to by...">column</a>()],
<a name="l02708"></a>02708                                               part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a03b6fedfe805d7fc73216da5cd33270e" title="Returns the width in screen columns of the part pointed to by data(). Takes multi-byte...">screenLength</a>());
<a name="l02709"></a>02709                             }
<a name="l02710"></a>02710                         }
<a name="l02711"></a>02711                     }
<a name="l02712"></a>02712 
<a name="l02713"></a>02713                     <span class="comment">/*</span>
<a name="l02714"></a>02714 <span class="comment">                    * If the last column doesn&apos;t fit on the same</span>
<a name="l02715"></a>02715 <span class="comment">                    * line as the other columns, we can fix that by starting it</span>
<a name="l02716"></a>02716 <span class="comment">                    * on its own line.</span>
<a name="l02717"></a>02717 <span class="comment">                    * However we can&apos;t do this for any of the columns</span>
<a name="l02718"></a>02718 <span class="comment">                    * 0..lastcolumn-1.</span>
<a name="l02719"></a>02719 <span class="comment">                    * If their sum exceeds the maximum width we try to fix this</span>
<a name="l02720"></a>02720 <span class="comment">                    * by iteratively</span>
<a name="l02721"></a>02721 <span class="comment">                    * ignoring the widest line parts in the width determination</span>
<a name="l02722"></a>02722 <span class="comment">                    * until</span>
<a name="l02723"></a>02723 <span class="comment">                    * we arrive at a series of column widths that fit into one</span>
<a name="l02724"></a>02724 <span class="comment">                    * line.</span>
<a name="l02725"></a>02725 <span class="comment">                    * The result is a layout where everything is nicely</span>
<a name="l02726"></a>02726 <span class="comment">                    * formatted</span>
<a name="l02727"></a>02727 <span class="comment">                    * except for a few overlong fragments.</span>
<a name="l02728"></a>02728 <span class="comment">                    * */</span>
<a name="l02729"></a>02729 
<a name="l02730"></a>02730                     leftwidth = 0;
<a name="l02731"></a>02731                     overlong_column_threshold = 0;
<a name="l02732"></a>02732                     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; lastcolumn; ++i) {
<a name="l02733"></a>02733                         leftwidth += col_width[i];
<a name="l02734"></a>02734                         upmax(overlong_column_threshold, col_width[i]);
<a name="l02735"></a>02735                     }
<a name="l02736"></a>02736 
<a name="l02737"></a>02737                 } <span class="keywordflow">while</span> (leftwidth &gt; width);
<a name="l02738"></a>02738 
<a name="l02739"></a>02739                 <span class="comment">/**************** Determine tab stops and last column handling</span>
<a name="l02740"></a>02740 <span class="comment">                * **********************/</span>
<a name="l02741"></a>02741 
<a name="l02742"></a>02742                 <span class="keywordtype">int</span> tabstop[maxcolumns];
<a name="l02743"></a>02743                 tabstop[0] = 0;
<a name="l02744"></a>02744                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; maxcolumns; ++i)
<a name="l02745"></a>02745                     tabstop[i] = tabstop[i - 1] + col_width[i - 1];
<a name="l02746"></a>02746 
<a name="l02747"></a>02747                 <span class="keywordtype">int</span> rightwidth = width - tabstop[lastcolumn];
<a name="l02748"></a>02748                 <span class="keywordtype">bool</span> print_last_column_on_own_line = <span class="keyword">false</span>;
<a name="l02749"></a>02749                 <span class="keywordflow">if</span> (rightwidth &lt; last_column_min_width &amp;&amp;
<a name="l02750"></a>02750                     <span class="comment">// if we don&apos;t have the minimum requested width for the last</span>
<a name="l02751"></a>02751                     <span class="comment">// column</span>
<a name="l02752"></a>02752                     (col_width[lastcolumn] == 0 || <span class="comment">// and all last columns are &gt;</span>
<a name="l02753"></a>02753                                                    <span class="comment">// overlong_column_threshold</span>
<a name="l02754"></a>02754                      rightwidth &lt; col_width[lastcolumn] <span class="comment">// or there is at least</span>
<a name="l02755"></a>02755                                                         <span class="comment">// one last column that</span>
<a name="l02756"></a>02756                                                         <span class="comment">// requires more than</span>
<a name="l02757"></a>02757                                                         <span class="comment">// the space available</span>
<a name="l02758"></a>02758                      )) {
<a name="l02759"></a>02759                     print_last_column_on_own_line = <span class="keyword">true</span>;
<a name="l02760"></a>02760                     rightwidth = last_column_own_line_max_width;
<a name="l02761"></a>02761                 }
<a name="l02762"></a>02762 
<a name="l02763"></a>02763                 <span class="comment">// If lastcolumn == 0 we must disable</span>
<a name="l02764"></a>02764                 <span class="comment">// print_last_column_on_own_line because</span>
<a name="l02765"></a>02765                 <span class="comment">// otherwise 2 copies of the last (and only) column would be</span>
<a name="l02766"></a>02766                 <span class="comment">// output.</span>
<a name="l02767"></a>02767                 <span class="comment">// Actually this is just defensive programming. It is currently</span>
<a name="l02768"></a>02768                 <span class="comment">// not</span>
<a name="l02769"></a>02769                 <span class="comment">// possible that lastcolumn==0 and</span>
<a name="l02770"></a>02770                 <span class="comment">// print_last_column_on_own_line==true</span>
<a name="l02771"></a>02771                 <span class="comment">// at the same time, because lastcolumn==0 =&gt;</span>
<a name="l02772"></a>02772                 <span class="comment">// tabstop[lastcolumn] == 0 =&gt;</span>
<a name="l02773"></a>02773                 <span class="comment">// rightwidth==width =&gt; rightwidth&gt;=last_column_min_width</span>
<a name="l02774"></a>02774                 <span class="comment">// (unless someone passes</span>
<a name="l02775"></a>02775                 <span class="comment">// a bullshit value &gt;100 for last_column_min_percent) =&gt; the</span>
<a name="l02776"></a>02776                 <span class="comment">// above if condition</span>
<a name="l02777"></a>02777                 <span class="comment">// is false =&gt; print_last_column_on_own_line==false</span>
<a name="l02778"></a>02778                 <span class="keywordflow">if</span> (lastcolumn == 0)
<a name="l02779"></a>02779                     print_last_column_on_own_line = <span class="keyword">false</span>;
<a name="l02780"></a>02780 
<a name="l02781"></a>02781                 <a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html">LineWrapper</a> lastColumnLineWrapper(width - rightwidth, width);
<a name="l02782"></a>02782                 <a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html">LineWrapper</a> interjectionLineWrapper(0, width);
<a name="l02783"></a>02783 
<a name="l02784"></a>02784                 part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a0cbe8ed79ab4958a70b957598dd76fa6" title="Reset iteration to the beginning of the current table.">restartTable</a>();
<a name="l02785"></a>02785 
<a name="l02786"></a>02786                 <span class="comment">/***************** Print out all rows of the table</span>
<a name="l02787"></a>02787 <span class="comment">                * *************************************/</span>
<a name="l02788"></a>02788 
<a name="l02789"></a>02789                 <span class="keywordflow">while</span> (part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a55d5c3e50f9c1d8cd48f518899a5a48c" title="Moves iteration to the next row (if any). Has to be called once after each call to...">nextRow</a>()) {
<a name="l02790"></a>02790                     <span class="keywordtype">int</span> x = -1;
<a name="l02791"></a>02791                     <span class="keywordflow">while</span> (part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a58b8743da57de2d108472eee60324df6" title="Moves iteration to the next part (if any). Has to be called once after each call...">next</a>()) {
<a name="l02792"></a>02792                         <span class="keywordflow">if</span> (part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#afa41382acabcd37ca70f7e8b9994b8c0" title="Returns the index (counting from 0) of the column in which the part pointed to by...">column</a>() &gt; lastcolumn)
<a name="l02793"></a>02793                             <span class="keywordflow">continue</span>; <span class="comment">// drop excess columns (can happen if</span>
<a name="l02794"></a>02794                                       <span class="comment">// lastcolumn == maxcolumns-1)</span>
<a name="l02795"></a>02795 
<a name="l02796"></a>02796                         <span class="keywordflow">if</span> (part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#afa41382acabcd37ca70f7e8b9994b8c0" title="Returns the index (counting from 0) of the column in which the part pointed to by...">column</a>() == 0) {
<a name="l02797"></a>02797                             <span class="keywordflow">if</span> (x &gt;= 0)
<a name="l02798"></a>02798                                 write(<span class="stringliteral">&quot;\n&quot;</span>, 1);
<a name="l02799"></a>02799                             x = 0;
<a name="l02800"></a>02800                         }
<a name="l02801"></a>02801 
<a name="l02802"></a>02802                         indent(write, x, tabstop[part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#afa41382acabcd37ca70f7e8b9994b8c0" title="Returns the index (counting from 0) of the column in which the part pointed to by...">column</a>()]);
<a name="l02803"></a>02803 
<a name="l02804"></a>02804                         <span class="keywordflow">if</span> ((part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#afa41382acabcd37ca70f7e8b9994b8c0" title="Returns the index (counting from 0) of the column in which the part pointed to by...">column</a>() &lt; lastcolumn) &amp;&amp;
<a name="l02805"></a>02805                             (part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#afa41382acabcd37ca70f7e8b9994b8c0" title="Returns the index (counting from 0) of the column in which the part pointed to by...">column</a>() &gt; 0 || part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a8ad1201d95bf0bd9453a731da8c15a10" title="Returns the index (counting from 0) of the line within the current column this part...">line</a>() &gt; 0 ||
<a name="l02806"></a>02806                              part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#ada26229add63bd479c7877f2f8e32908" title="Returns the current part of the iteration.">data</a>()[part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a557e521cb41e951a34df2737d25f9dce" title="Returns the length of the part pointed to by data() in raw chars (not UTF-8 characters)...">length</a>()] == <span class="charliteral">&apos;\t&apos;</span> ||
<a name="l02807"></a>02807                              part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#ada26229add63bd479c7877f2f8e32908" title="Returns the current part of the iteration.">data</a>()[part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a557e521cb41e951a34df2737d25f9dce" title="Returns the length of the part pointed to by data() in raw chars (not UTF-8 characters)...">length</a>()] == <span class="charliteral">&apos;\v&apos;</span>)) {
<a name="l02808"></a>02808                             write(part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#ada26229add63bd479c7877f2f8e32908" title="Returns the current part of the iteration.">data</a>(), part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a557e521cb41e951a34df2737d25f9dce" title="Returns the length of the part pointed to by data() in raw chars (not UTF-8 characters)...">length</a>());
<a name="l02809"></a>02809                             x += part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a03b6fedfe805d7fc73216da5cd33270e" title="Returns the width in screen columns of the part pointed to by data(). Takes multi-byte...">screenLength</a>();
<a name="l02810"></a>02810                         } <span class="keywordflow">else</span> <span class="comment">// either part.column() == lastcolumn or we are</span>
<a name="l02811"></a>02811                                <span class="comment">// in the special case of</span>
<a name="l02812"></a>02812                                <span class="comment">// an interjection that doesn&apos;t contain \v or \t</span>
<a name="l02813"></a>02813                         {
<a name="l02814"></a>02814                             <span class="comment">// NOTE: This code block is not necessarily executed</span>
<a name="l02815"></a>02815                             <span class="comment">// for</span>
<a name="l02816"></a>02816                             <span class="comment">// each line, because some rows may have fewer</span>
<a name="l02817"></a>02817                             <span class="comment">// columns.</span>
<a name="l02818"></a>02818 
<a name="l02819"></a>02819                             <a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html">LineWrapper</a>&amp; lineWrapper =
<a name="l02820"></a>02820                                 (part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#afa41382acabcd37ca70f7e8b9994b8c0" title="Returns the index (counting from 0) of the column in which the part pointed to by...">column</a>() == 0) ? interjectionLineWrapper
<a name="l02821"></a>02821                                                      : lastColumnLineWrapper;
<a name="l02822"></a>02822 
<a name="l02823"></a>02823                             <span class="keywordflow">if</span> (!print_last_column_on_own_line ||
<a name="l02824"></a>02824                                 part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#afa41382acabcd37ca70f7e8b9994b8c0" title="Returns the index (counting from 0) of the column in which the part pointed to by...">column</a>() != lastcolumn)
<a name="l02825"></a>02825                                 lineWrapper.<a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#add20eca40865ad892d6c28b412ac14d5" title="Process, wrap and output the next piece of data.">process</a>(write, part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#ada26229add63bd479c7877f2f8e32908" title="Returns the current part of the iteration.">data</a>(),
<a name="l02826"></a>02826                                                     part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a557e521cb41e951a34df2737d25f9dce" title="Returns the length of the part pointed to by data() in raw chars (not UTF-8 characters)...">length</a>());
<a name="l02827"></a>02827                         }
<a name="l02828"></a>02828                     } <span class="comment">// while</span>
<a name="l02829"></a>02829 
<a name="l02830"></a>02830                     <span class="keywordflow">if</span> (print_last_column_on_own_line) {
<a name="l02831"></a>02831                         part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a96c448939f33a811174ea7b5addb312e" title="Reset iteration to the beginning of the current row.">restartRow</a>();
<a name="l02832"></a>02832                         <span class="keywordflow">while</span> (part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a58b8743da57de2d108472eee60324df6" title="Moves iteration to the next part (if any). Has to be called once after each call...">next</a>()) {
<a name="l02833"></a>02833                             <span class="keywordflow">if</span> (part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#afa41382acabcd37ca70f7e8b9994b8c0" title="Returns the index (counting from 0) of the column in which the part pointed to by...">column</a>() == lastcolumn) {
<a name="l02834"></a>02834                                 write(<span class="stringliteral">&quot;\n&quot;</span>, 1);
<a name="l02835"></a>02835                                 <span class="keywordtype">int</span> _ = 0;
<a name="l02836"></a>02836                                 indent(write, _, width - rightwidth);
<a name="l02837"></a>02837                                 lastColumnLineWrapper.<a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#add20eca40865ad892d6c28b412ac14d5" title="Process, wrap and output the next piece of data.">process</a>(
<a name="l02838"></a>02838                                     write, part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#ada26229add63bd479c7877f2f8e32908" title="Returns the current part of the iteration.">data</a>(), part.<a class="code" href="../../de/dc9/classoption_1_1PrintUsageImplementation_1_1LinePartIterator.html#a557e521cb41e951a34df2737d25f9dce" title="Returns the length of the part pointed to by data() in raw chars (not UTF-8 characters)...">length</a>());
<a name="l02839"></a>02839                             }
<a name="l02840"></a>02840                         }
<a name="l02841"></a>02841                     }
<a name="l02842"></a>02842 
<a name="l02843"></a>02843                     write(<span class="stringliteral">&quot;\n&quot;</span>, 1);
<a name="l02844"></a>02844                     lastColumnLineWrapper.<a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a9383db9fd3fb18ce091db63ce0b149fd" title="Writes out all remaining data from the LineWrapper using write. Unlike process()...">flush</a>(write);
<a name="l02845"></a>02845                     interjectionLineWrapper.<a class="code" href="../../de/d50/classoption_1_1PrintUsageImplementation_1_1LineWrapper.html#a9383db9fd3fb18ce091db63ce0b149fd" title="Writes out all remaining data from the LineWrapper using write. Unlike process()...">flush</a>(write);
<a name="l02846"></a>02846                 }
<a name="l02847"></a>02847             }
<a name="l02848"></a>02848         }
<a name="l02849"></a>02849     };
<a name="l02850"></a>02850 
<a name="l03085"></a>03085     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> OStream&gt;
<a name="l03086"></a><a class="code" href="../../df/de0/namespaceoption.html#a13564b6055a677443dfe6cdcc86875a4">03086</a>     <span class="keywordtype">void</span> <a class="code" href="../../df/de0/namespaceoption.html#a13564b6055a677443dfe6cdcc86875a4" title="Outputs a nicely formatted usage string with support for multi-column formatting...">printUsage</a>(OStream&amp; prn, <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> width = 80,
<a name="l03087"></a>03087                     <span class="keywordtype">int</span> last_column_min_percent = 50,
<a name="l03088"></a>03088                     <span class="keywordtype">int</span> last_column_own_line_max_percent = 75) {
<a name="l03089"></a>03089         <a class="code" href="../../d5/deb/structoption_1_1PrintUsageImplementation_1_1OStreamWriter.html">PrintUsageImplementation::OStreamWriter&lt;OStream&gt;</a> write(prn);
<a name="l03090"></a>03090         <a class="code" href="../../da/dfb/structoption_1_1PrintUsageImplementation.html#ab38c4198c5cccea2ccd992c8e014df70">PrintUsageImplementation::printUsage</a>(write, usage, width,
<a name="l03091"></a>03091                                              last_column_min_percent,
<a name="l03092"></a>03092                                              last_column_own_line_max_percent);
<a name="l03093"></a>03093     }
<a name="l03094"></a>03094 
<a name="l03095"></a>03095     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Function&gt;
<a name="l03096"></a><a class="code" href="../../df/de0/namespaceoption.html#a7237545fbfc09d061d736fb19ab6f572">03096</a>     <span class="keywordtype">void</span> <a class="code" href="../../df/de0/namespaceoption.html#a13564b6055a677443dfe6cdcc86875a4" title="Outputs a nicely formatted usage string with support for multi-column formatting...">printUsage</a>(Function* prn, <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[], <span class="keywordtype">int</span> width = 80,
<a name="l03097"></a>03097                     <span class="keywordtype">int</span> last_column_min_percent = 50,
<a name="l03098"></a>03098                     <span class="keywordtype">int</span> last_column_own_line_max_percent = 75) {
<a name="l03099"></a>03099         <a class="code" href="../../df/dae/structoption_1_1PrintUsageImplementation_1_1FunctionWriter.html">PrintUsageImplementation::FunctionWriter&lt;Function&gt;</a> write(prn);
<a name="l03100"></a>03100         <a class="code" href="../../da/dfb/structoption_1_1PrintUsageImplementation.html#ab38c4198c5cccea2ccd992c8e014df70">PrintUsageImplementation::printUsage</a>(write, usage, width,
<a name="l03101"></a>03101                                              last_column_min_percent,
<a name="l03102"></a>03102                                              last_column_own_line_max_percent);
<a name="l03103"></a>03103     }
<a name="l03104"></a>03104 
<a name="l03105"></a>03105     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Temporary&gt;
<a name="l03106"></a><a class="code" href="../../df/de0/namespaceoption.html#a33d90526c90d451b6b619ce558e8ddc9">03106</a>     <span class="keywordtype">void</span> <a class="code" href="../../df/de0/namespaceoption.html#a13564b6055a677443dfe6cdcc86875a4" title="Outputs a nicely formatted usage string with support for multi-column formatting...">printUsage</a>(<span class="keyword">const</span> Temporary&amp; prn, <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[],
<a name="l03107"></a>03107                     <span class="keywordtype">int</span> width = 80, <span class="keywordtype">int</span> last_column_min_percent = 50,
<a name="l03108"></a>03108                     <span class="keywordtype">int</span> last_column_own_line_max_percent = 75) {
<a name="l03109"></a>03109         <a class="code" href="../../d8/da8/structoption_1_1PrintUsageImplementation_1_1TemporaryWriter.html">PrintUsageImplementation::TemporaryWriter&lt;Temporary&gt;</a> write(prn);
<a name="l03110"></a>03110         <a class="code" href="../../da/dfb/structoption_1_1PrintUsageImplementation.html#ab38c4198c5cccea2ccd992c8e014df70">PrintUsageImplementation::printUsage</a>(write, usage, width,
<a name="l03111"></a>03111                                              last_column_min_percent,
<a name="l03112"></a>03112                                              last_column_own_line_max_percent);
<a name="l03113"></a>03113     }
<a name="l03114"></a>03114 
<a name="l03115"></a>03115     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Syscall&gt;
<a name="l03116"></a><a class="code" href="../../df/de0/namespaceoption.html#a14761cee5fd28c4ba85de2437f72dc2e">03116</a>     <span class="keywordtype">void</span> <a class="code" href="../../df/de0/namespaceoption.html#a13564b6055a677443dfe6cdcc86875a4" title="Outputs a nicely formatted usage string with support for multi-column formatting...">printUsage</a>(Syscall* prn, <span class="keywordtype">int</span> fd, <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[],
<a name="l03117"></a>03117                     <span class="keywordtype">int</span> width = 80, <span class="keywordtype">int</span> last_column_min_percent = 50,
<a name="l03118"></a>03118                     <span class="keywordtype">int</span> last_column_own_line_max_percent = 75) {
<a name="l03119"></a>03119         <a class="code" href="../../d3/d44/structoption_1_1PrintUsageImplementation_1_1SyscallWriter.html">PrintUsageImplementation::SyscallWriter&lt;Syscall&gt;</a> write(prn, fd);
<a name="l03120"></a>03120         <a class="code" href="../../da/dfb/structoption_1_1PrintUsageImplementation.html#ab38c4198c5cccea2ccd992c8e014df70">PrintUsageImplementation::printUsage</a>(write, usage, width,
<a name="l03121"></a>03121                                              last_column_min_percent,
<a name="l03122"></a>03122                                              last_column_own_line_max_percent);
<a name="l03123"></a>03123     }
<a name="l03124"></a>03124 
<a name="l03125"></a>03125     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Function, <span class="keyword">typename</span> Stream&gt;
<a name="l03126"></a><a class="code" href="../../df/de0/namespaceoption.html#a8f43c70b443cfab0e5c00affc034fea7">03126</a>     <span class="keywordtype">void</span> <a class="code" href="../../df/de0/namespaceoption.html#a13564b6055a677443dfe6cdcc86875a4" title="Outputs a nicely formatted usage string with support for multi-column formatting...">printUsage</a>(Function* prn, Stream* stream, <span class="keyword">const</span> <a class="code" href="../../dc/dfe/structoption_1_1Descriptor.html" title="Describes an option, its help text (usage) and how it should be parsed.">Descriptor</a> usage[],
<a name="l03127"></a>03127                     <span class="keywordtype">int</span> width = 80, <span class="keywordtype">int</span> last_column_min_percent = 50,
<a name="l03128"></a>03128                     <span class="keywordtype">int</span> last_column_own_line_max_percent = 75) {
<a name="l03129"></a>03129         <a class="code" href="../../de/d60/structoption_1_1PrintUsageImplementation_1_1StreamWriter.html">PrintUsageImplementation::StreamWriter&lt;Function, Stream&gt;</a> write(prn,
<a name="l03130"></a>03130                                                                        stream);
<a name="l03131"></a>03131         <a class="code" href="../../da/dfb/structoption_1_1PrintUsageImplementation.html#ab38c4198c5cccea2ccd992c8e014df70">PrintUsageImplementation::printUsage</a>(write, usage, width,
<a name="l03132"></a>03132                                              last_column_min_percent,
<a name="l03133"></a>03133                                              last_column_own_line_max_percent);
<a name="l03134"></a>03134     }
<a name="l03135"></a>03135 }
<a name="l03136"></a>03136 <span class="comment">// namespace option</span>
<a name="l03137"></a>03137 
<a name="l03138"></a>03138 <span class="preprocessor">#endif </span><span class="comment">/* OPTIONPARSER_H_ */</span>
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 5 Sep 2016 for Beam Longitudinal Dynamics code (BLonD) by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
